/* -LICENSE-START-
 ** Copyright (c) 2020 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import Utility

public protocol PTPPacketDecoderDelegate: AnyObject {
	// Responses
	func onResponseReceived(_ transactionId: TransactionID, _ responseCode: ResponseCode)
	
	// Generic Data Received
	func onDataReceived(_ dataContainer: Container)
	// Decoded Data Received
	func onDeviceInfoReceived(_ deviceInfo: PTPDeviceInfo)
	func onDevicePropDescReceived(_ devicePropDesc: PTPDevicePropDesc)
	func onWhiteBalanceKelvinReceived(_ whiteBalance: Int16)
	func onWhiteBalanceTintReceived(_ tint: Int16)
	func onApertureFstopReceived(_ fstop: Float, _ stopUnits: LensConfig.ApertureUnits)
	func onExposureReceived(_ exposure: Int32)
	func onShutterSpeedReceived(_ shutterSpeed: Int32)
	func onShutterAngleReceived(_ shutterAngleX100: Int32)
	func onISOReceived(_ iso: Int) -> Void
	func onGainReceived(_ sensorGain: Int) -> Void
	func onNDFilterReceived(_ stops: Float)
	func onRecordTimeRemainingReceived(_ remainingRecordTimes: [String], _ remainingRecordTimesInMinutes: [Int16])
	func onBatteryLevelReceived(_ percentage: UInt8)
	func onRecordingResolutionReceived(_ width: Int16, _ height: Int16)
	func onOffSpeedFrameRateReceived(_ offSpeedFrameRate: Int16)
	func onOffSpeedEnabledReceived(_ enabled: Bool)
    
    // Derived from the above callbacks but not directly recieved
    func onApertureNormalisedReceived(_ normalisedAperture: Float)
	
	// Generic Events Received
	func onDevicePropertyChanged(_ devicePropCode: DevicePropCode)
	func onDevicePropertyDescriptionChanged(_ devicePropCode: DevicePropCode)
	// Decoded Events Received
	func onRecordingStarted()
	func onRecordingStopped()
}

// Provide default handler so that delegates are not forced to handle all of them
public extension PTPPacketDecoderDelegate {
	func onResponseReceived(_ transactionId: TransactionID, _ responseCode: ResponseCode) {}
	func onDataReceived(_ dataContainer: Container) {}
	func onDeviceInfoReceived(_ deviceInfo: PTPDeviceInfo) {}
	func onDevicePropDescReceived(_ devicePropDesc: PTPDevicePropDesc) {}
	func onWhiteBalanceKelvinReceived(_ whiteBalance: Int16) {}
	func onWhiteBalanceTintReceived(_ tint: Int16) {}
	func onApertureFstopReceived(_ fstop: Float, _ stopUnits: LensConfig.ApertureUnits) {}
    func onApertureNormalisedReceived(_ normalisedAperture: Float) {}
	func onExposureReceived(_ exposure: Int32) {}
	func onShutterSpeedReceived(_ shutterSpeed: Int32) {}
	func onShutterAngleReceived(_ shutterAngleX100: Int32) {}
	func onISOReceived(_ iso: Int) -> Void {}
	func onGainReceived(_ sensorGain: Int) -> Void {}
	func onNDFilterReceived(_ stops: Float) {}
	func onRecordTimeRemainingReceived(_ remainingRecordTimes: [String], _ remainingRecordTimesInMinutes: [Int16]) {}
	func onBatteryLevelReceived(_ percentage: UInt8) {}
	func onRecordingResolutionReceived(_ width: Int16, _ height: Int16) {}
	func onOffSpeedFrameRateReceived(_ offSpeedFrameRate: Int16) {}
	func onOffSpeedEnabledReceived(_ enabled: Bool) {}
	func onDevicePropertyChanged(_ devicePropCode: DevicePropCode) {}
	func onDevicePropertyDescriptionChanged(_ devicePropCode: DevicePropCode) {}
	func onRecordingStarted() {}
	func onRecordingStopped() {}
}

public struct PTPPacketDecoder {

    public static func DecodePacket(_ data: inout [UInt8], respondTo ptpPacketDecoderDelegate: PTPPacketDecoderDelegate) {
		// decode packet. use static functions for response and event types
		var container = Container()
		if !container.deserializeContainerDataFromByteArray(data) { return }
		switch (container.m_containerData.type) {
		case ContainerData.ContainerType.ResponseBlock:
			let responseCode = ResponseCode(rawValue: container.m_containerData.code)
			Logger.LogWithInfo("Response: \(String(describing: responseCode)). TransactionID: \(container.m_containerData.transactionId)")
			ptpPacketDecoderDelegate.onResponseReceived(container.m_containerData.transactionId, responseCode ?? ResponseCode.Undefined)
		case ContainerData.ContainerType.EventBlock:
			let eventCode = EventCode(rawValue: container.m_containerData.code) ?? EventCode.Undefined
			
			switch eventCode {
			case EventCode.DevicePropChanged:
				// PIMA 15740: 2000 table 21: Event Dataset shows that the parameters must be 4-bytes in size, even though the eventual value type isn't
				let typeSize = MemoryLayout<UInt32>.size
				let validPayloadSize = Int(container.m_containerData.length) - PTPTypes.kContainerHeaderSize
				if (validPayloadSize < typeSize) {
					return
				}

				let data = NSData(bytes: container.m_containerData.payload, length: typeSize)
				var rawData: UInt16 = 0
				data.getBytes(&rawData, length: MemoryLayout<UInt16>.size)
				let devicePropCode : DevicePropCode = DevicePropCode(rawValue: rawData) ?? DevicePropCode.Undefined
				
				Logger.LogWithInfo("Event: \(String(describing: eventCode)). Prop: \(devicePropCode)")
				ptpPacketDecoderDelegate.onDevicePropertyChanged(devicePropCode)
				break;
			case EventCode.DevicePropDescChanged:
				let typeSize = MemoryLayout<DevicePropCode>.size
				let validPayloadSize = Int(container.m_containerData.length) - PTPTypes.kContainerHeaderSize
				if (validPayloadSize < typeSize) {
					return
				}
				
				let data = NSData(bytes: container.m_containerData.payload, length: typeSize)
				var devicePropCode : DevicePropCode = DevicePropCode.Undefined
				data.getBytes(&devicePropCode, length: typeSize)
				
				Logger.LogWithInfo("Event: \(String(describing: eventCode)). Prop Desc: \(devicePropCode)")
                ptpPacketDecoderDelegate.onDevicePropertyChanged(devicePropCode)
                ptpPacketDecoderDelegate.onDevicePropertyDescriptionChanged(devicePropCode)
			case EventCode.DeviceInfoChanged:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.DeviceReset:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.CaptureComplete:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.StoreFull:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.StoreAdded:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.StoreRemoved:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.ObjectAdded:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.ObjectRemoved:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			case EventCode.CancelTransaction:
				Logger.LogWithInfo("Event: \(String(describing: eventCode)).")
			default:
				Logger.LogWithInfo("Unhandled Event: \(eventCode).")
			}
		case ContainerData.ContainerType.DataBlock:
			let operationCode = OperationCode(rawValue: container.m_containerData.code)
			Logger.LogWithInfo("Data received for Operation: \(String(describing: operationCode)) for TransactionID: \(container.m_containerData.transactionId)")
			ptpPacketDecoderDelegate.onDataReceived(container)
		default:
			Logger.LogWarning("Unknown packet received!")
		}
	}
	
	public static func DecodePayloadAsDeviceInfo(_ container: Container, respondTo ptpPacketDecoderDelegate: PTPPacketDecoderDelegate) -> PTPDeviceInfo? {
		let validPayloadSize = Int(container.m_containerData.length) - PTPTypes.kContainerHeaderSize
		let data = NSData(bytes: container.m_containerData.payload, length: validPayloadSize)

		let deviceInfo = PTPDeviceInfo()
		guard (OperationCode(rawValue: container.m_containerData.code) == OperationCode.GetDeviceInfo) else { return nil }
		
		if deviceInfo.deserializeFromPayload(data) {
			deviceInfo.printDebug()
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onDeviceInfoReceived(deviceInfo)
			}
			return deviceInfo
		}

		return nil
	}
	
	public static func DecodePayloadAsDevicePropDesc(_ container: Container, respondTo ptpPacketDecoderDelegate: PTPPacketDecoderDelegate) -> PTPDevicePropDesc? {
		let validPayloadSize = Int(container.m_containerData.length) - PTPTypes.kContainerHeaderSize
		let data = NSData(bytes: container.m_containerData.payload, length: validPayloadSize)
		
		let devicePropDesc = PTPDevicePropDesc()
		guard (OperationCode(rawValue: container.m_containerData.code) == OperationCode.GetDevicePropDesc) else { return nil }
		
		if devicePropDesc.deserializeFromPayload(data) {
			devicePropDesc.printDebug()
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onDevicePropDescReceived(devicePropDesc)
			}
			// when prop desc changed the normalised slider position should be adjusted
            switch devicePropDesc.m_devicePropCode {
				case .FNumber:
                    guard let currentValue = (devicePropDesc.getCurrentValue() as? UInt16) else {break}
                    guard let minValue = (devicePropDesc.getMinimumValue() as? UInt16) else {break}
                    guard let maxValue = (devicePropDesc.getMaximumValue() as? UInt16) else {break}
                    if minValue...maxValue ~= currentValue {
                        DispatchQueue.main.async {
                            ptpPacketDecoderDelegate.onApertureFstopReceived(Float(currentValue) / 100.0, LensConfig.ApertureUnits.Fstops)
                            ptpPacketDecoderDelegate.onApertureNormalisedReceived(Float(currentValue - minValue) / Float(maxValue - minValue))
                        }
                    }
				default:
					break
			}
			return devicePropDesc
		}
		
		return nil
	}
	
    public static func DecodePayloadAsDevicePropValue(_ container: Container, _ devicePropCode: DevicePropCode, respondTo ptpPacketDecoderDelegate: PTPPacketDecoderDelegate, _ ptopDevicePropDescs: [PTPDevicePropDesc]) -> Bool {
		let validPayloadSize = Int(container.m_containerData.length) - PTPTypes.kContainerHeaderSize
		let data = NSData(bytes: container.m_containerData.payload, length: validPayloadSize)
		
		guard (OperationCode(rawValue: container.m_containerData.code) == OperationCode.GetDevicePropValue) else { return false }
		switch devicePropCode {
		case .BatteryLevel:
			var batteryLevel: UInt8 = 0
			data.getBytes(&batteryLevel, length: MemoryLayout.size(ofValue: batteryLevel))
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onBatteryLevelReceived(batteryLevel)
			}
		case .ImageSize:
			var imageSize: String = ""
			let deserialiser = PTPDeserialiser(data)
			do {
				try deserialiser.deserialise(&imageSize)
				DispatchQueue.main.async {
					let dimensionArray = imageSize.components(separatedBy: "x")
					if (dimensionArray.count == 2) {
						let width = (dimensionArray[0] as NSString).integerValue
						let height = (dimensionArray[1] as NSString).integerValue
						ptpPacketDecoderDelegate.onRecordingResolutionReceived(Int16(width), Int16(height))
					}
				}
			} catch {
				Logger.LogError("Failed to decode image size data container")
			}
			
		case .FNumber:
			var fnumber: Int16 = 0
            var minFNumber: UInt16 = 0
            var maxFNumber: UInt16 = 2200
            
			data.getBytes(&fnumber, length: MemoryLayout<UInt16>.size)
        
            if let FNumberProp = ptopDevicePropDescs.first(where: { $0.m_devicePropCode == devicePropCode }) {
                if ((FNumberProp.getMinimumValue() as? UInt16) != nil) && ((FNumberProp.getMaximumValue() as? UInt16) != nil)
                {
                    minFNumber = FNumberProp.getMinimumValue() as! UInt16
                    maxFNumber = FNumberProp.getMaximumValue() as! UInt16
                }
            }
            
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onApertureFstopReceived(Float(fnumber) / 100.0, LensConfig.ApertureUnits.Fstops)	// Always in f-stops
                ptpPacketDecoderDelegate.onApertureNormalisedReceived((Float(fnumber) - Float(minFNumber)) / (Float(maxFNumber) - Float(minFNumber)))
			}
		case .FocalLength:
			var focalLength: UInt32 = 0
			data.getBytes(&focalLength, length: MemoryLayout<UInt32>.size)
			DispatchQueue.main.async {
				// No notification of focal length yet
			}
		case .FocusDistance:
			var focalLength: Int16 = 0
			data.getBytes(&focalLength, length: MemoryLayout<Int16>.size)
			DispatchQueue.main.async {
				// No notification of focal distance yet
			}
		case .ExposureIndex:
			var iso: Int16 = 0
			data.getBytes(&iso, length: MemoryLayout<Int16>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onISOReceived(Int(iso))
			}
		case .BMD_ShutterSpeed:
			var shutterSpeed: Int16 = 0
			data.getBytes(&shutterSpeed, length: MemoryLayout<Int16>.size)
			DispatchQueue.main.async {
				// PTP fires both shutter speed and angle. UI always updates both. Choose angle over speed for now
//				ptpPacketDecoderDelegate.onShutterSpeedReceived(Int32(shutterSpeed))
			}
		case .BMD_ShutterAngle:
			var shutterAngleX100: UInt16 = 0
			data.getBytes(&shutterAngleX100, length: MemoryLayout<UInt16>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onShutterAngleReceived(Int32(shutterAngleX100))
			}
		case .BMD_FocusPosition:
			var focusPosition: Int32 = 0
			data.getBytes(&focusPosition, length: MemoryLayout<Int32>.size)
			DispatchQueue.main.async {
				// No notification of focus position yet for UI
			}
		case .BMD_WhiteBalanceKelvin:
			var whiteBalanceKelvin: Int16 = 0
			data.getBytes(&whiteBalanceKelvin, length: MemoryLayout<UInt16>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onWhiteBalanceKelvinReceived(Int16(whiteBalanceKelvin))
			}
		case .BMD_WhiteBalanceTint:
			var whiteBalanceTint: Int8 = 0
			data.getBytes(&whiteBalanceTint, length: MemoryLayout<Int8>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onWhiteBalanceTintReceived(Int16(whiteBalanceTint))
			}
		case .BMD_FrameRate:
			var frameRate: UInt32 = 0
			data.getBytes(&frameRate, length: MemoryLayout<UInt32>.size)
			DispatchQueue.main.async {
				// No notification of focal length yet
			}
		case .BMD_OffSpeedFrameRate:
			var offSpeedFrameRate: UInt32 = 0
			data.getBytes(&offSpeedFrameRate, length: MemoryLayout<UInt32>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onOffSpeedFrameRateReceived(Int16(offSpeedFrameRate))
			}
		case .BMD_OffSpeedEnabled:
			var offSpeedEnabled: UInt8 = 0
			data.getBytes(&offSpeedEnabled, length: MemoryLayout<UInt8>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onOffSpeedEnabledReceived(offSpeedEnabled != 0)
			}
		case .BMD_ZoomPosition:
			var zoomPosition: Int32 = 0
			data.getBytes(&zoomPosition, length: MemoryLayout<Int32>.size)
			DispatchQueue.main.async {
				// No notification of zoom positions yet
			}
		case .BMD_RecordingState:
			var recording: UInt8 = 0
			data.getBytes(&recording, length: MemoryLayout<UInt8>.size)
			DispatchQueue.main.async {
				if (recording != 0) { ptpPacketDecoderDelegate.onRecordingStarted() }
				else { ptpPacketDecoderDelegate.onRecordingStopped() }
			}
		case .BMD_NDFilter:
			var ptpNDFilter: PTPTypes.ptp_fixed_t = 0
			data.getBytes(&ptpNDFilter, length: MemoryLayout<PTPTypes.ptp_fixed_t>.size)
			DispatchQueue.main.async {
				ptpPacketDecoderDelegate.onNDFilterReceived(PTPTypes.PTPFloatFromFixed(ptpNDFilter))
			}
		default:
			break
		}
		
		return true
	}
}
