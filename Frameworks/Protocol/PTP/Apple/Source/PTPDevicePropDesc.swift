/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

import Foundation
import Utility

public class RangedDevicePropValues<T> {
	var m_minimum: T
	var m_maximum: T
	var m_step: T
	
	public init(_ minimum: T, _ maximum: T, _ step: T) {
		m_minimum = minimum
		m_maximum = maximum
		m_step = step
	}
}

public class PTPDevicePropDesc {
	public var m_devicePropCode: DevicePropCode = DevicePropCode.Undefined
	public var m_dataTypeCode: DataTypeCode = DataTypeCode.Undefined
	public var m_permission: DevicePropPermissions = DevicePropPermissions.ReadOnly
	public var m_defaultValue = Data()
	public var m_currentValue = Data()
	public var m_propertyForm: DevicePropForm = DevicePropForm.None
	
	var m_minimumValue = Data()
	var m_maximumValue = Data()
	var m_stepValue = Data()
	var m_enums = [Data]()
	
	public init() {}
	
	internal static func GetGenericType<T>(_ object: T) -> T.Type {
		return T.self
	}
	
	internal static func GetMemoryType(_ dataTypeCode: DataTypeCode) -> Any.Type {
		switch dataTypeCode {
		case .Int8:		return Int8.self
		case .UInt8:	return UInt8.self
		case .Int16:	return Int16.self
		case .UInt16:	return UInt16.self
		case .Int32:	return Int32.self
		case .UInt32:	return UInt32.self
		case .Int64:	return Int64.self
		case .UInt64:	return UInt64.self
		case .String:	return String.self
		default:		return Int8.self
		}
	}
	
	internal static func GetMemorySize(_ dataTypeCode: DataTypeCode) -> Int {
		switch dataTypeCode {
		case .Int8:		return MemoryLayout<Int8>.size
		case .UInt8:	return MemoryLayout<UInt8>.size
		case .Int16:	return MemoryLayout<Int16>.size
		case .UInt16:	return MemoryLayout<UInt16>.size
		case .Int32:	return MemoryLayout<Int32>.size
		case .UInt32:	return MemoryLayout<UInt32>.size
		case .Int64:	return MemoryLayout<Int64>.size
		case .UInt64:	return MemoryLayout<UInt64>.size
		default:		return 0
		}
	}
	
	internal static func GetMemoryObject(_ dataTypeCode: DataTypeCode, _ data: Data) -> Any {
		guard data.count >= PTPDevicePropDesc.GetMemorySize(dataTypeCode) else { return Int8() }
		switch dataTypeCode {
		case .Int8:		return data.withUnsafeBytes { $0.load(as: Int8.self) }
		case .UInt8:	return data.withUnsafeBytes { $0.load(as: UInt8.self) }
		case .Int16:	return data.withUnsafeBytes { $0.load(as: Int16.self) }
		case .UInt16:	return data.withUnsafeBytes { $0.load(as: UInt16.self) }
		case .Int32:	return data.withUnsafeBytes { $0.load(as: Int32.self) }
		case .UInt32:	return data.withUnsafeBytes { $0.load(as: UInt32.self) }
		case .Int64:	return data.withUnsafeBytes { $0.load(as: Int64.self) }
		case .UInt64:	return data.withUnsafeBytes { $0.load(as: UInt64.self) }
		case .String:	return String(data: data, encoding: String.Encoding.ascii)!
		default:		return Int8()
		}
	}
	
	public func deserializeFromPayload(_ data: NSData) -> Bool {
		let deserialiser = PTPDeserialiser(data)
		do {
			try deserialiser.deserialise(&m_devicePropCode)
			try deserialiser.deserialise(&m_dataTypeCode)
			try deserialiser.deserialise(&m_permission)
			
			let elemSize = PTPDevicePropDesc.GetMemorySize(m_dataTypeCode)

			if (m_dataTypeCode == DataTypeCode.String) {
				// Special case
				var defaultValue: String = ""
				try deserialiser.deserialise(&defaultValue)
				var currentValue: String = ""
				try deserialiser.deserialise(&currentValue)
				
				m_defaultValue = defaultValue.data(using: .ascii)!
				m_currentValue = currentValue.data(using: .ascii)!
			}
			else {
				m_defaultValue = try deserialiser.deserialise(elemSize)
				m_currentValue = try deserialiser.deserialise(elemSize)
			}
			
			try deserialiser.deserialise(&m_propertyForm)
			
			if (m_propertyForm == DevicePropForm.Range) {
				m_minimumValue = try deserialiser.deserialise(elemSize)
				m_maximumValue = try deserialiser.deserialise(elemSize)
				m_stepValue = try deserialiser.deserialise(elemSize)
			} else if (m_propertyForm == DevicePropForm.Enum) {
				if (m_dataTypeCode == DataTypeCode.String) {
					var stringEnums = [String]()
					stringEnums = try deserialiser.deserialise()
					for item in stringEnums {
						m_enums.append(item.data(using: .ascii)!)
					}
				}
				else {
					m_enums = try deserialiser.deserialise(elemSize)
					if (m_enums.count > 0) {
						m_minimumValue = m_enums.first!
						m_maximumValue = m_enums.last!
					}
				}
			}
			
			return true
		} catch {
			// Failed to deserialise PTP device info
			return false
		}
	}
	
	public func getDefaultValue() -> Any {
		return PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, m_defaultValue)
	}
	
	public func getCurrentValue() -> Any {
		return PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, m_currentValue)
	}

	public func getMinimumValue() -> Any {
		return PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, m_minimumValue)
	}
	
	public func getMaximumValue() -> Any {
		return PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, m_maximumValue)
	}
	
	public func getStepValue() -> Any {
		return PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, m_stepValue)
	}
	
	public func getRangeValues() -> RangedDevicePropValues<Any> {
		let ret = RangedDevicePropValues<Any>(getMinimumValue(), getMaximumValue(), getStepValue())
		return ret
	}
	
	public func getEnumValues() -> [Any] {
		var ret = [Any]()
		for data in m_enums {
			ret.append(PTPDevicePropDesc.GetMemoryObject(m_dataTypeCode, data))
		}
		return ret
	}
	
	public func printDebug() {
		Logger.LogWithInfo("DevicePropDesc:")
		Logger.LogWithInfo("m_devicePropCode: \(m_devicePropCode)")
		Logger.LogWithInfo("m_permission: \(m_permission)")
		Logger.LogWithInfo("m_defaultValue: \(getDefaultValue())")
		Logger.LogWithInfo("m_currentValue: \(getCurrentValue())")
		Logger.LogWithInfo("m_propertyForm: \(m_propertyForm)")
		
		if (m_propertyForm == DevicePropForm.Range) {
			Logger.LogWithInfo("Range:")
			Logger.LogWithInfo("\t Minimum: \(getMinimumValue())")
			Logger.LogWithInfo("\t Maximum: \(getMaximumValue())")
			Logger.LogWithInfo("\t Step: \(getStepValue())")
		} else if (m_propertyForm == DevicePropForm.Enum) {
			Logger.LogWithInfo("Enums:")
			Logger.LogWithInfo("\(getEnumValues())")
		}
	}
}
