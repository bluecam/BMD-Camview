/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/


import Foundation
import Utility

public struct ContainerData {
	public enum ContainerType: UInt16 {
		case Undefined
		case CommandBlock
		case DataBlock
		case ResponseBlock
		case EventBlock
	}
	
	public var length: UInt32 = UInt32(PTPTypes.kContainerHeaderSize)
	public var type: ContainerType = ContainerType.Undefined
	public var code: UInt16 = 0								// Can be operation, response, or event codes
	public var transactionId: TransactionID = PTPTypes.kInvalidCaptureTransactionId
	public var payload = Array<UInt8>(repeating: 0, count: PTPTypes.kMaxPayloadSize)

	public func serialize() -> [UInt8] {
		var byteArray = [UInt8]()
		byteArray.append(contentsOf: UtilityFunctions.ToByteArray(length))
		byteArray.append(contentsOf: UtilityFunctions.ToByteArray(type.rawValue))
		byteArray.append(contentsOf: UtilityFunctions.ToByteArray(code))
		byteArray.append(contentsOf: UtilityFunctions.ToByteArray(transactionId))

		let payloadSize = Int(length) - PTPTypes.kContainerHeaderSize
		byteArray.append(contentsOf: payload[0..<payloadSize])

		return byteArray
	}
	
	public mutating func deserialize(_ data: [UInt8]) -> Bool {
		var index = 0
		var size = MemoryLayout.size(ofValue: length)
		length = UtilityFunctions.FromByteArray(Array(data[index..<size]))
		index += size
		
		if (length < PTPTypes.kContainerHeaderSize || length > PTPTypes.kMaxPacketSize || length > data.count) {
			return false
		}
		
		size = MemoryLayout.size(ofValue: type.rawValue)
		let value: UInt16 = UtilityFunctions.FromByteArray(Array(data[index..<index + size]))
		if let testType = ContainerType(rawValue: value) {
			type = testType
		}
		else {
			return false
		}
		index += size
		
		size = MemoryLayout.size(ofValue: code)
		code = UtilityFunctions.FromByteArray(Array(data[index..<index + size]))
		index += size
		
		size = MemoryLayout.size(ofValue: transactionId)
		transactionId = UtilityFunctions.FromByteArray(Array(data[index..<index + size]))
		
		payload.insert(contentsOf: data[PTPTypes.kContainerHeaderSize..<data.count], at: 0)
		return true
	}
}

public struct Container {
	public var m_containerData: ContainerData = ContainerData()
	
	public init() { }

	public mutating func reset() {
		m_containerData = ContainerData()
	}
	
	public func serializeContainerDataToByteArray() -> [UInt8] {
		return m_containerData.serialize()
	}
	
	public mutating func deserializeContainerDataFromByteArray(_ data: [UInt8]) -> Bool {
		guard data.count >= PTPTypes.kContainerHeaderSize else { return false }
		reset()
		
		return m_containerData.deserialize(data)
	}
	
	public mutating func appendToEndOfPayload<T>(_ value: T) {
		let byteArray: [UInt8] = UtilityFunctions.ToByteArray(value)
		let payloadSize: Int = Int(m_containerData.length) - PTPTypes.kContainerHeaderSize
		m_containerData.payload.insert(contentsOf: byteArray, at: payloadSize)
		
		let bytesAdded = MemoryLayout<T>.size
		m_containerData.length += UInt32(bytesAdded)
	}
}
