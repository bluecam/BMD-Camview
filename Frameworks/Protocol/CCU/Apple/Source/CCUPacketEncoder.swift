/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import CoreBluetooth
import Utility

public protocol CCUPacketEncoderDelegate: AnyObject {
    func onCCUPacketEncoded(_ data: Data)
    func onPowerPacketEncoded(_ data: Data)
}

public class CCUPacketEncoder {
    weak var m_ccuPacketEncoderDelegate: CCUPacketEncoderDelegate?

	public init() {}
	
	public func setDelegate(_ delegate: CCUPacketEncoderDelegate) {
		m_ccuPacketEncoderDelegate = delegate
	}

    fileprivate func validateAndSendCCUCommand(_ command: CCUPacketTypes.Command?) {
        if command == nil {
            Logger.LogError("Command is nil, cannot send.")
            return
        }

        let packetIsValid = CCUValidationFunctions.ValidateCCUPacket(packetAsData: command!.serialize())
        if packetIsValid {
            m_ccuPacketEncoderDelegate?.onCCUPacketEncoded(command!.serialize())
        } else {
            command!.Log()
            Logger.LogError("Trying to send invalid CCU Packet.")
        }
    }

    // Video commands
    public func writeWhiteBalance(_ whiteBalance: Int16, _ tint: Int16) {
        let command = CCUEncodingFunctions.CreateVideoWhiteBalanceCommand(whiteBalance, tint)
        validateAndSendCCUCommand(command)
    }

    public func writeAutoWhiteBalance() {
        let command = CCUEncodingFunctions.CreateVideoSetAutoWBCommand()
        validateAndSendCCUCommand(command)
    }

    public func writeRecordingFormat(_ recordingFormatData: CCUPacketTypes.RecordingFormatData) {
        let command = CCUEncodingFunctions.CreateRecordingFormatCommand(recordingFormatData: recordingFormatData)
        validateAndSendCCUCommand(command)
    }

	public func writeApertureOrdinalOffset(_ offsetValue: Int16, _ stepLength: CCUPacketTypes.ApertureStepLength) {
		let dataArray: [Int16] = [offsetValue, stepLength.rawValue]
		let command = CCUEncodingFunctions.CreateCommandFromArray(dataArray, CCUPacketTypes.Category.Lens, CCUPacketTypes.LensParameter.ApertureOrdinal.rawValue, operationType: CCUPacketTypes.OperationType.OffsetValue)
		validateAndSendCCUCommand(command)
	}

	public func writeApertureNormalised(_ apertureNormalised: Int16) {
		let command = CCUEncodingFunctions.CreateFixed16Command(apertureNormalised, CCUPacketTypes.Category.Lens, CCUPacketTypes.LensParameter.ApertureNormalised.rawValue)
		validateAndSendCCUCommand(command)
	}

    public func writeShutterSpeed(_ shutter: Int32) {
        let command = CCUEncodingFunctions.CreateCommand(shutter, CCUPacketTypes.Category.Video, CCUPacketTypes.VideoParameter.ShutterSpeed.rawValue)
        validateAndSendCCUCommand(command)
	}

	public func writeShutterAngle(_ shutterAngleX100: Int32) {
		let command = CCUEncodingFunctions.CreateCommand(shutterAngleX100, CCUPacketTypes.Category.Video, CCUPacketTypes.VideoParameter.ShutterAngle.rawValue)
		validateAndSendCCUCommand(command)
	}

    public func writeSensorGain(_ sensorGain: Int) {
        let sensorGainValue = UInt16(sensorGain) / VideoConfig.kSentSensorGainBase
        let command = CCUEncodingFunctions.CreateVideoSensorGainCommand(value: Int8(sensorGainValue))
        validateAndSendCCUCommand(command)
    }

	public func writeISO(_ isoValue: Int) {
		let command = CCUEncodingFunctions.CreateVideoISOCommand(value: isoValue)
		validateAndSendCCUCommand(command)
	}

	public func writeGain(_ gain: Decibels) {
		let command = CCUEncodingFunctions.CreateVideoGainCommand(Int8(gain))
		validateAndSendCCUCommand(command)
	}

	public func writeNDFilterStop(_ stop: CCUPacketTypes.ccu_fixed_t, _ displayMode: VideoConfig.NDFilterDisplayMode) {
		let command = CCUEncodingFunctions.CreateNDFilterStopCommand(stop, displayMode)
		validateAndSendCCUCommand(command)
	}

    public func writeFocusPosition(_ focusPosition: Int32)
    {
        let command = CCUEncodingFunctions.CreateFixed16Command(CCUPacketTypes.CCUFixedFromFloat(Float(focusPosition)/Float(65435)), CCUPacketTypes.Category.Lens, CCUPacketTypes.LensParameter.Focus.rawValue)
        validateAndSendCCUCommand(command)
    }

    // Transport commands
    public func writeTransportPacket(_ transportInfo: TransportInfo) {
        let command = CCUEncodingFunctions.CreateTransportInfoCommand(info: transportInfo)
        validateAndSendCCUCommand(command)
    }

    // Slate commands
	public func writeReel(_ reel: Int16, _ editable: Bool) {
        let command = CCUEncodingFunctions.CreateMetadataReelCommand(reel, editable)
        validateAndSendCCUCommand(command)
    }

    public func writeSceneTags(_ sceneTag: CCUPacketTypes.MetadataSceneTag, _ locationTag: CCUPacketTypes.MetadataLocationTypeTag, _ timeTag: CCUPacketTypes.MetadataDayNightTag) {
        let command = CCUEncodingFunctions.CreateMetadataSceneTagsCommand(sceneTag, locationTag, timeTag)
        validateAndSendCCUCommand(command)
    }

    public func writeScene(_ scene: String) {
        let command = CCUEncodingFunctions.CreateStringCommand(scene, CCUPacketTypes.Category.Metadata, CCUPacketTypes.MetadataParameter.Scene.rawValue)
        validateAndSendCCUCommand(command)
    }

    public func writeTake(_ takeNumber: Int, _ takeTag: CCUPacketTypes.MetadataTakeTag) {
        let command = CCUEncodingFunctions.CreateMetadataTakeCommand(UInt8(takeNumber), takeTag)
        validateAndSendCCUCommand(command)
    }

    public func writeGoodTake(_ goodTake: Bool) {
        let command = CCUEncodingFunctions.CreateCommand(goodTake, CCUPacketTypes.Category.Metadata, CCUPacketTypes.MetadataParameter.GoodTake.rawValue)
        validateAndSendCCUCommand(command)
    }

    public func writePower(_ turnPowerOn: Bool) {
        m_ccuPacketEncoderDelegate?.onPowerPacketEncoded(turnPowerOn ? CameraStatus.kPowerOn : CameraStatus.kPowerOff)
    }

    // Location commands
    public func writeLocation(_ latitude: UInt64, _ longitude: UInt64) {
        let dataArray: [Int64] = [Int64(bitPattern: latitude), Int64(bitPattern: longitude)]
        let command = CCUEncodingFunctions.CreateCommandFromArray(dataArray, CCUPacketTypes.Category.Configuration, CCUPacketTypes.ConfigurationParameter.Location.rawValue)
        validateAndSendCCUCommand(command)
    }

    // Display command
    public func setTimecodeSource(_ source: CCUPacketTypes.DisplayTimecodeSource) {
        let command = CCUEncodingFunctions.CreateCommand(source.rawValue, CCUPacketTypes.Category.Display, CCUPacketTypes.DisplayParameter.TimecodeSource.rawValue)
        validateAndSendCCUCommand(command)
    }
}
