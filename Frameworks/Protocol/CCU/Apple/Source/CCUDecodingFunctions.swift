/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import Utility

public struct CCUDecodingFunctions {
    public static func DecodeCCUPacket(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let byteArray = [UInt8](data)
        let isValid: Bool = CCUValidationFunctions.ValidateCCUPacket(packetAsByteArray: byteArray)

        if isValid {
            let commandLength = byteArray[CCUPacketTypes.PacketFormatIndex.CommandLength]
            let category = CCUPacketTypes.Category(rawValue: byteArray[CCUPacketTypes.PacketFormatIndex.Category])!
            let parameter = byteArray[CCUPacketTypes.PacketFormatIndex.Parameter]

            let dataLength = commandLength - CCUPacketTypes.kCCUCommandHeaderSize
            let payloadOffset = CCUPacketTypes.kCUUPayloadOffset
            let payloadRange: Range<Data.Index> = Data.Index(payloadOffset) ..< Data.Index(payloadOffset + dataLength)
            let payloadData = data.subdata(in: payloadRange)

            try DecodePayloadData(for: category, parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        } else {
            throw CCUDecodingError.PacketValidationFailed
        }
    }

    public static func DecodePayloadData(for category: CCUPacketTypes.Category, parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        switch category
        {
        case .Lens:
            try DecodeLensCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        case .Video:
            try DecodeVideoCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        case .Status:
            try DecodeStatusCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        case .Media:
            try DecodeMediaCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        case .Metadata:
            try DecodeMetadataCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        case .Display:
            try DecodeDisplayCategory(parameter: parameter, payloadData: payloadData, respondTo: ccuPacketDecoderDelegate)
        default:
            break
        }
    }

    public static func ConvertPayloadData<T>(from data: Data) throws -> [T] {
        let typeSize = MemoryLayout<T>.size
        let byteCount = data.count

        let conversionClosure = {
            (ptr: UnsafePointer<T>) -> [T] in
            let ptrToArrayOfType = UnsafeBufferPointer<T>(start: ptr, count: byteCount / typeSize)
            let arrayOfType = [T](ptrToArrayOfType)
            return arrayOfType
        }
        let payload: [T] = data.withUnsafeBytes(conversionClosure)
        return payload
    }
    
    public static func ConvertPayloadDataWithExpectedCount<T>(from data: Data, expectedCount: Int) throws -> [T] {
        let typeSize = MemoryLayout<T>.size
        let byteCount = data.count
        if typeSize > byteCount {
            Logger.LogWithInfo("Payload type size (\(typeSize)) is smaller than data size (\(byteCount))")
            throw CCUDecodingError.PayloadConversionFailed
        }
        
        let convertedCount = byteCount / typeSize
        if expectedCount != convertedCount {
            Logger.LogWithInfo("Payload expected count (\(expectedCount)) not equal to converted count (\(convertedCount))")
            throw CCUDecodingError.PayloadConversionFailed
        }
        
        let payload: [T] = data.withUnsafeBytes { (ptr: UnsafePointer<T>) -> [T] in
            return [T](UnsafeBufferPointer<T>(start: ptr, count: convertedCount))
        }
        
        return payload
    }

    public static func ConvertPayloadDataWithExpectedCount<T>(from data: Data, expectedCountMin: Int, expectedCountMax: Int) throws -> [T] {
        let typeSize = MemoryLayout<T>.size
        let byteCount = data.count
        if typeSize > byteCount {
            Logger.LogWithInfo("Payload type size (\(typeSize)) is smaller than data size (\(byteCount))")
            throw CCUDecodingError.PayloadConversionFailed
        }

        let convertedCount = byteCount / typeSize
        let convertedCountValid = convertedCount >= expectedCountMin && convertedCount <= expectedCountMax
        if !convertedCountValid {
            Logger.LogWithInfo("Payload expected count (\(expectedCountMin)) - (\(expectedCountMax)) does not contain converted count (\(convertedCount))")
            throw CCUDecodingError.PayloadConversionFailed
        }

        let payload: [T] = data.withUnsafeBytes { (ptr: UnsafePointer<T>) -> [T] in
            return [T](UnsafeBufferPointer<T>(start: ptr, count: convertedCount))
        }

        return payload
    }

    public static func ConvertPayloadDataToString(from data: Data) throws -> String {
        let string = String(data: data, encoding: String.Encoding.utf8)
        return string ?? ""
    }

    // Lens Category decoding functions
    public static func DecodeLensCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.LensParameter(rawValue: parameter)
        if parameterType != nil {
            switch parameterType!
            {
            case .ApertureFstop:
                try DecodeApertureFstop(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .ApertureNormalised:
				try DecodeApertureNormalised(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for LensParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

	public static func ConvertCCUApertureToFstop(_ ccuAperture: Int16) -> Float {
		// fnum = sqrt(2^AV) = 2^(AV/2) if AV is valid; otherwise fnum = 0.0
		var fstop: Float = 0.0
		if ccuAperture != CCUPacketTypes.kLensAperture_NoLens
		{
			fstop = pow(2, CCUPacketTypes.CCUFloatFromFixed(ccuAperture) / 2)
		}
		return fstop
	}

    public static func DecodeApertureFstop(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int16] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCountMin: 1, expectedCountMax: 2)
        let ccuAperture: Int16 = data[0]
		let fstop = ConvertCCUApertureToFstop(ccuAperture)
        let stopUnits = data.count == 2 ? LensConfig.ApertureUnits(rawValue: Int16(data[1])) : LensConfig.ApertureUnits.Fstops;
        
        if let stopUnits = stopUnits {
			ccuPacketDecoderDelegate.onApertureFstopReceived(fstop, stopUnits)
        }
    }

	public static func DecodeApertureNormalised(data: Data, respondTo packetDecodeDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int16] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		let ccuApertureNormalised: Int16 = data[0]
		let apertureNormalised = CCUPacketTypes.CCUFloatFromFixed(ccuApertureNormalised)

		packetDecodeDelegate.onApertureNormalisedReceived(apertureNormalised)
	}

    // Video Category decoding functions
    public static func DecodeVideoCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.VideoParameter(rawValue: parameter)
        if parameterType != nil {
            switch parameterType!
            {
            case .SensorGain:
                try DecodeSensorGain(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            case .ManualWB:
                try DecodeManualWB(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            case .Exposure:
                try DecodeExposure(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            case .RecordingFormat:
				try DecodeRecordingFormat(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .AutoExposureMode:
				try DecodeAutoExposureMode(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .ShutterAngle:
				try DecodeShutterAngle(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .ShutterSpeed:
				try DecodeShutterSpeed(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .Gain:
				try DecodeGain(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .ISO:
				try DecodeISO(data: payloadData, respondTo: ccuPacketDecoderDelegate)
			case .NDFilterStop:
				try DecodeNDFilterStop(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for VideoParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

    public static func DecodeSensorGain(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
        let sensorGainValue = Int(data[0])
        let sensorGain = sensorGainValue * Int(VideoConfig.kReceivedSensorGainBase)
        ccuPacketDecoderDelegate.onISOReceived(sensorGain)
    }

    public static func DecodeManualWB(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int16] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 2)

        let whiteBalance: Int16 = data[0]
        let tint: Int16 = data[1]

        ccuPacketDecoderDelegate.onWhiteBalanceReceived(whiteBalance, tint)
    }

    public static func DecodeExposure(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int32] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
        let shutterSpeed = data[0]
        ccuPacketDecoderDelegate.onExposureReceived(shutterSpeed)
    }

    public static func DecodeRecordingFormat(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int16] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 5)

        var recordingFormatData = CCUPacketTypes.RecordingFormatData()
        recordingFormatData.frameRate = data[0]
        recordingFormatData.offSpeedFrameRate = data[1]
        recordingFormatData.width = data[2]
        recordingFormatData.height = data[3]

        let flags = UInt16(data[4])
        recordingFormatData.mRateEnabled = (flags & CCUPacketTypes.VideoRecordingFormat.FileMRate.rawValue) > 0
        recordingFormatData.offSpeedEnabled = (flags & CCUPacketTypes.VideoRecordingFormat.SensorOffSpeed.rawValue) > 0
        recordingFormatData.interlacedEnabled = (flags & CCUPacketTypes.VideoRecordingFormat.Interlaced.rawValue) > 0
        recordingFormatData.windowedModeEnabled = (flags & CCUPacketTypes.VideoRecordingFormat.WindowedMode.rawValue) > 0

        ccuPacketDecoderDelegate.onRecordingFormatReceived(recordingFormatData)
    }
	
	public static func DecodeAutoExposureMode(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		if let autoExposureMode = CCUPacketTypes.AutoExposureMode(rawValue: data[0]) {
			ccuPacketDecoderDelegate.onAutoExposureModeReceived(autoExposureMode)
		}
	}
	
	public static func DecodeShutterAngle(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int32] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		let shutterAngleX100 = data[0]
		ccuPacketDecoderDelegate.onShutterAngleReceived(shutterAngleX100)
	}
	
	public static func DecodeShutterSpeed(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int32] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		let shutterSpeed = data[0]
		ccuPacketDecoderDelegate.onShutterSpeedReceived(shutterSpeed)
	}
	
	public static func DecodeGain(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		let gain = data[0]
		ccuPacketDecoderDelegate.onGainReceived(Decibels(gain))
	}
	
	public static func DecodeISO(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int32] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 1)
		let iso = data[0]
		ccuPacketDecoderDelegate.onISOReceived(Int(iso))
	}

	static func DecodeNDFilterStop(data: Data, respondTo ccuPacketDecodedDelegate: CCUPacketDecoderDelegate) throws {
		let data: [Int16] = try ConvertPayloadData(from: data)
		let stop = CCUPacketTypes.CCUFloatFromFixed(data[0])

		var displayMode = VideoConfig.NDFilterDisplayMode.Stop
		if data.count > 1 {
			if let mode = VideoConfig.NDFilterDisplayMode.init(rawValue: data[1]) {
				displayMode = mode
			}
		}

		ccuPacketDecodedDelegate.onNDFilterStopReceived(stop, displayMode)
	}

    // Status Category decoding functions
    public static func DecodeStatusCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.StatusParameter(rawValue: parameter)
        if parameterType != nil {
            switch parameterType!
            {
            case .MediaStatus:
                try DecodeMediaStatus(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            case .RemainingRecordTime:
                try DecodeRemainingRecordTime(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            case .CameraSpec:
                try DecodeCameraSpec(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for StatusParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

    public static func DecodeMediaStatus(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadData(from: data)
		let slotCount = data.count

		var statuses = [CCUPacketTypes.MediaStatus](repeating: CCUPacketTypes.MediaStatus.None, count: slotCount)
        for slotIndex in 0 ..< slotCount {
			if let slotStatus = CCUPacketTypes.MediaStatus(rawValue: data[slotIndex]) {
				statuses[slotIndex] = slotStatus
			}
        }

		ccuPacketDecoderDelegate.onMediaStatusReceived(statuses)
    }

    public static func DecodeRemainingRecordTime(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int16] = try ConvertPayloadData(from: data)

        struct SecondsWithOverflow {
            var seconds: UInt
            var over: Bool
        }

        func simplifyTime(time: Int16) -> SecondsWithOverflow {
            var seconds = Int(time) // positive value -> unit: second
            var over = false

            if time < 0 { // negative value -> unit: minute
                var minutes = 0
                if time == Int16.min { // more time remaining than fits in CCU message
                    minutes = Int(Int16.max)
                    over = true
                } else {
                    minutes = Int(-time)
                }
                seconds = minutes * 60
            }

            return SecondsWithOverflow(seconds: UInt(seconds), over: over)
        }

        func makeTimeLabel(_ time: SecondsWithOverflow) -> String {
            if time.seconds == 0 { return String.Localized("Transport.Full") }

            var label = ""
            let hours = time.seconds / 60 / 60
            if hours > 0 {
                label += "\(String(format: "%02d", hours)):"
            }
            let minutes = time.seconds / 60 % 60
            label += "\(String(format: "%02d", minutes)):"
            let seconds = time.seconds % 60
            label += "\(String(format: "%02d", seconds))"

            if time.over { label += "+" }

            return label
        }

		let slotCount = data.count
		var labels = [String](repeating: "", count: slotCount)
		var minutes = [Int16](repeating: 0, count: slotCount)
        for slotIndex in 0 ..< slotCount {
            let remainingTime = simplifyTime(time: data[slotIndex])
            minutes[slotIndex] = Int16(remainingTime.seconds / 60)
            labels[slotIndex] = makeTimeLabel(remainingTime)
        }

        ccuPacketDecoderDelegate.onRecordTimeRemainingReceived(labels, minutes)
    }
    
    public static func DecodeCameraSpec(data: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [UInt8] = try ConvertPayloadDataWithExpectedCount(from: data, expectedCount: 4)
        
		let cameraModel = CameraModel.from(value: data[1])
		ccuPacketDecoderDelegate.onCameraSpecificationReceived(cameraModel)
    }

    // Media Category decoding functions
    public static func DecodeMediaCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.MediaParameter(rawValue: parameter)

        if parameterType != nil {
            switch parameterType!
            {
            case .TransportMode:
                try DecodeTransportMode(data: payloadData, respondTo: ccuPacketDecoderDelegate)
            default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for MediaParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

	public static func DecodeTransportMode(data: Data, respondTo delegate: CCUPacketDecoderDelegate) throws {
		let data: [UInt8] = try ConvertPayloadData(from: data)
		do {
			let info = try TransportInfo(from: data)
			delegate.onTransportInfoReceived(info)
		} catch TransportInfo.DecodeError.UnrecognisedMode(let message) {
			Logger.LogWarning(message)
		}
	}

    // Media Category decoding functions
    public static func DecodeMetadataCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.MetadataParameter(rawValue: parameter)
        if parameterType != nil {
            switch parameterType!
            {
            case .Reel:
                try DecodeReel(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .SceneTags:
                try DecodeSceneTags(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .Scene:
                try DecodeScene(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .Take:
                try DecodeTake(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .GoodTake:
                try DecodeGoodTake(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .SlateForType:
                try DecodeSlateForType(payloadData, respondTo: ccuPacketDecoderDelegate)
            case .SlateForName:
                try DecodeSlateForName(payloadData, respondTo: ccuPacketDecoderDelegate)
            default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for MediaParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

    // Metadata decoding functions
    // Important: All metadata CCU commands are undocumented and are subject to change in a future release
    
    public static func DecodeReel(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int16] = try ConvertPayloadData(from: payloadData)
        let reelNumber: Int16 = data[0]
		let editable = data.count <= 1 || data[1] != 0
        ccuPacketDecoderDelegate.onReelReceived(reelNumber, editable)
    }

    public static func DecodeSceneTags(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: payloadData, expectedCount: 3)
        let sceneTag = CCUPacketTypes.MetadataSceneTag(rawValue: data[0])
        let locationType = CCUPacketTypes.MetadataLocationTypeTag(rawValue: UInt8(bitPattern: data[1]))
        let dayOrNight = CCUPacketTypes.MetadataDayNightTag(rawValue: UInt8(bitPattern: data[2]))

        if sceneTag != nil && locationType != nil && dayOrNight != nil {
            ccuPacketDecoderDelegate.onSceneTagsReceived(sceneTag!, locationType!, dayOrNight!)
        } else {
            Logger.LogWithInfo("Failed enum cast: MetadataSceneTag (\(data[0])), MetadataLocationTypeTag (\(data[1])), MetadataDayNightTag (\(data[2])).")
            throw CCUDecodingError.EnumCastFailed
        }
    }

    public static func DecodeScene(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let sceneString: String = try ConvertPayloadDataToString(from: payloadData)
        ccuPacketDecoderDelegate.onSceneReceived(sceneString)
    }

    public static func DecodeTake(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: payloadData, expectedCount: 2)
        let takeNumber: Int8 = data[0]
        let takeTag = CCUPacketTypes.MetadataTakeTag(rawValue: data[1])
        if takeTag != nil {
            ccuPacketDecoderDelegate.onTakeReceived(takeNumber, takeTag!)
        } else {
            Logger.LogWithInfo("Failed enum cast: MetadataTakeTag (\(data[1])).")
            throw CCUDecodingError.EnumCastFailed
        }
    }

    public static func DecodeGoodTake(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: payloadData, expectedCount: 1)
        let goodTake: Int8 = data[0]

        ccuPacketDecoderDelegate.onGoodTakeReceived(goodTake == 1)
    }

    public static func DecodeSlateForType(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadData(from: payloadData)
        if data.count < 1 {
            throw CCUDecodingError.PayloadConversionFailed
        }

        let slateForType: CCUPacketTypes.MetadataSlateForType? = CCUPacketTypes.MetadataSlateForType(rawValue: data[0])
        if slateForType == nil {
            throw CCUDecodingError.PayloadConversionFailed
        }

        ccuPacketDecoderDelegate.onSlateForTypeReceived(slateForType!)
    }

    public static func DecodeSlateForName(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        var name: String = try ConvertPayloadDataToString(from: payloadData)

		// NOTE: Camera software versions between 7.5 and 7.7.x send the full path of
		// the clip file name. When this is detected, strip the system folders, first
		// folder (volume), and final file extension.
		let s = NSString(string: name)
		let match = s.range(of: "^/mnt/s[0-9]+/", options: .regularExpression)
		if (match.lowerBound != NSNotFound) {
			let matchEnd = name.index(name.startIndex, offsetBy: match.upperBound - 1)
			name.removeSubrange(name.startIndex...matchEnd)
		}

		ccuPacketDecoderDelegate.onSlateForNameReceived(name)
    }

    // Display Category decoding functions
    public static func DecodeDisplayCategory(parameter: UInt8, payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let parameterType = CCUPacketTypes.DisplayParameter(rawValue: parameter)
        if parameterType != nil {
            switch parameterType!
            {
            case .TimecodeSource:
                try DecodeTimecodeSource(payloadData, respondTo: ccuPacketDecoderDelegate)
            default:
                break
            }
        } else {
            Logger.LogWithInfo("Invalid value for DisplayParameter: \(parameter).")
            throw CCUGeneralError.InvalidParameter
        }
    }

    // Display decoding functions

    public static func DecodeTimecodeSource(_ payloadData: Data, respondTo ccuPacketDecoderDelegate: CCUPacketDecoderDelegate) throws {
        let data: [Int8] = try ConvertPayloadDataWithExpectedCount(from: payloadData, expectedCount: 1)
        let source: CCUPacketTypes.DisplayTimecodeSource = CCUPacketTypes.DisplayTimecodeSource(rawValue: data[0]) ?? CCUPacketTypes.DisplayTimecodeSource.Timecode
        
        ccuPacketDecoderDelegate.onTimecodeSourceReceived(source)
    }

    // Timecode decoding
    public static let kTimecodeDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    public static let kTimecodeSize = MemoryLayout<UInt32>.size
	public static let kTimecodeDropFrameMask : UInt32 = 0x80000000

    public static func TimecodeToString(timecode: UInt32) -> String {
        var str: String = ""
        let digitCount = kTimecodeSize * 2
        var shift: Int = kTimecodeSize * 8 - 4
		let dropFrame = (timecode & kTimecodeDropFrameMask) > 0
		
        // Convert BCD timecode to string
        for i in 0 ..< digitCount {
			let mask = i == 0 ? 0x3 : 0xF
            let digit: Int = (Int(timecode) >> shift) & mask

            if digit < 10 {
                str += kTimecodeDigits[digit]
            } else {
                str += "-"
            }

            if (i % 2 == 1) && (i < digitCount - 1) {
				str += dropFrame && i >= 5 ? ";" : ":"
            }

            shift -= 4
        }

        return str
    }
}
