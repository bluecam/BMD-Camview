/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import CoreBluetooth
import Utility
import BluetoothControl
import CCU
#if os(OSX)
import USBControl
import PTP
#elseif os(iOS)
import UIKit
#endif

enum TransportControl {
	case Bluetooth
#if os(OSX)
    case USB
#endif
	case None
}

#if os(OSX)
extension CameraControlInterface:
    USBConnectionManagerDelegate,
    PTPPacketDecoderDelegate {
    // USBConnectionManagerDelegate
    public func updateDiscoveredUSBPTPDevices(_ usbPTPDevices: [USBControl.USBBulkDevice]) {
        m_initialConnectionToUIDelegate?.updateDiscoveredUSBPTPDevices(usbPTPDevices)
    }
    
    public func connectedToUSBDevice(_ usbPTPDevices: USBControl.USBBulkDevice) {
        m_usbPtpInterface = USBPTPController(device: usbPTPDevices)
        m_usbPtpInterface?.setPacketDecodedDelegate(self)
        m_connectionStatus |= ConnectionStatusFlags.kConnected
        
        Logger.Log("Connected to \(String(describing: usbPTPDevices.getName()))")
        
        updateAllUI()
    }
    
    public func disconnectedFromUSBDevice() {
        m_usbPtpInterface = nil
        m_connectionStatus = ConnectionStatusFlags.kNone
        m_connectionStatusDelegate?.onDisconnection()
    }
    
    public func onRecordingStarted() {
        m_cameraState.hasRecordingError = m_cameraState.anyMediaWithError;
        m_recordControlToUIDelegate?.setRecording(true)
    }
    
    public func onRecordingStopped() {
        m_recordControlToUIDelegate?.setRecording(false)
    }
}
#endif

public class CameraControlInterface:
    BluetoothConnectionManagerDelegate,
    InitialConnectionFromUIDelegate,
    PacketReceivedDelegate,
    CCUPacketDecoderDelegate,
    CCUPacketEncoderDelegate,
    OutgoingSlateFromUIDelegate,
    OutgoingCameraControlFromUIDelegate,
    OutgoingRecordControlFromUIDelegate,
    OutgoingPowerFromUIDelegate,
    LocationServicesDelegate {
    let m_btConnectionManager: BluetoothConnectionManager
    var m_btPeripheralInterface: PeripheralInterface?
    let m_ccuDecoder: CCUPacketDecoder
    let m_ccuEncoder: CCUPacketEncoder
    var m_cameraState: CameraState

#if os(OSX)
    let m_usbConnectionManager: USBConnectionManager
    var m_usbPtpInterface: USBPTPController?
#elseif os(iOS)
    let m_locationServices: LocationServices
#endif

    var m_diskTimer: Timer?
    private var m_isSuspended: Bool = false
    let kDiskInfoDelay: Double = 0.2
	
	var m_shutterValueIsAngle: Bool = true
	var m_sensorGainIsISO: Bool = true
	
	var m_userInstigatedConnection: Bool = false

    struct ConnectionStatusFlags {
        static let kNone: UInt8 = 0x00
        static let kPower: UInt8 = 0x01
        static let kConnected: UInt8 = 0x02
        static let kPaired: UInt8 = 0x04
        static let kVersionsVerified: UInt8 = 0x08
        static let kInitialPayloadReceived: UInt8 = 0x10
        static let kCameraReady: UInt8 = 0x20
    }

    var m_connectionStatus: UInt8 = 0

    public weak var m_initialConnectionToUIDelegate: InitialConnectionToUIDelegate?
    public weak var m_cameraControlToUIDelegate: IncomingCameraControlToUIDelegate?
    public weak var m_slateToUIDelegate: IncomingSlateToUIDelegate?
    public weak var m_recordControlToUIDelegate: IncomingRecordControlToUIDelegate?
    public weak var m_connectionStatusDelegate: ConnectionStatusToUIDelegate?
    public weak var m_cameraNameDelegate: CameraNameDelegate?

    public init() {
        m_btConnectionManager = BluetoothConnectionManager()
        m_ccuDecoder = CCUPacketDecoder()
        m_ccuEncoder = CCUPacketEncoder()
        m_cameraState = CameraState()

    #if os(OSX)
        m_usbConnectionManager = USBConnectionManager()
        m_usbConnectionManager.setDelegate(self)
    #endif

    #if os(iOS)
        // Remove macro to enable location services on MacOS
        m_locationServices = LocationServices()
        m_locationServices.setDelegate(self)
        m_locationServices.updateLocation()
    #endif

        m_btConnectionManager.setDelegate(self)
        m_ccuDecoder.setDelegate(self)
        m_ccuEncoder.setDelegate(self)

		m_cameraState.expectedApertureNormalisedx100.m_expectedValueNotReceivedCallback = {
			[weak self]() -> Void in
			if let cameraControl = self {
				let apertureNormalised: Float = cameraControl.m_cameraState.apertureNormalised
				cameraControl.m_cameraControlToUIDelegate?.onApertureNormalisedReceived(apertureNormalised)
			}
		}

        m_cameraState.expectedOffSpeedFrameRate.m_expectedValueNotReceivedCallback = {
            [weak self]() -> Void in
            if let cameraControl = self {
                let offSpeedEnabled: Bool = cameraControl.m_cameraState.recordingFormatData.offSpeedEnabled
                let offSpeedFrameRate: Int16 = cameraControl.m_cameraState.recordingFormatData.offSpeedFrameRate
                cameraControl.m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(offSpeedEnabled, offSpeedFrameRate)
            }
        }

		m_cameraState.expectedShutterSpeed.m_expectedValueNotReceivedCallback = {
			[weak self]() -> Void in
			if let cameraControl = self {
				let shutterSpeed: Int32 = cameraControl.m_cameraState.shutterSpeed
				cameraControl.m_cameraControlToUIDelegate?.onShutterSpeedReceived(shutterSpeed)
			}
		}
		
		m_cameraState.expectedISOValue.m_expectedValueNotReceivedCallback = {
			[weak self]() -> Void in
			if let cameraControl = self {
				let isoValues = VideoConfig.kISOValues[cameraControl.m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
				if let isoIndex = isoValues.firstIndex(of: cameraControl.m_cameraState.ISO) {
					cameraControl.m_cameraControlToUIDelegate?.onISOReceived(isoIndex)
				}
			}
		}
    }
	
	internal func getCurrentTransportControl() -> TransportControl {
		if (m_btPeripheralInterface?.getPeripheral() != nil) {
			return TransportControl.Bluetooth
		}
		
    #if os(OSX)
        if (m_usbPtpInterface != nil) {
            return TransportControl.USB
        }
    #endif
		
		return TransportControl.None
	}
    
    public func setSuspended(_ suspended: Bool) {
        m_isSuspended = suspended
    }
    
    public func updateAllUI() {
        onControlViewLoaded()
        onSlateViewLoaded()
        onTransportViewLoaded()
    }

    public func onControlViewLoaded() {
        m_cameraControlToUIDelegate?.onCameraSpecificationReceived(m_cameraState.cameraModel)
        m_cameraControlToUIDelegate?.onTransportModeReceived(m_cameraState.transportInfo.transportMode)
		m_cameraControlToUIDelegate?.onNDFilterStopReceived(m_cameraState.ndFilterStop, m_cameraState.ndFilterDisplayMode)
        let whiteBalancePresetIndex = VideoConfig.GetWhiteBalancePresetFromValues(m_cameraState.whiteBalance, m_cameraState.tint)
        m_cameraControlToUIDelegate?.onWhiteBalanceReceived(m_cameraState.whiteBalance, m_cameraState.tint, whiteBalancePresetIndex)
		if (m_shutterValueIsAngle) {
			m_cameraControlToUIDelegate?.onShutterAngleReceived(m_cameraState.shutterAngle)
		} else {
			m_cameraControlToUIDelegate?.onShutterSpeedReceived(m_cameraState.shutterSpeed)
		}
        m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(m_cameraState.recordingFormatData.offSpeedEnabled, m_cameraState.recordingFormatData.offSpeedFrameRate)
		m_cameraControlToUIDelegate?.onApertureFstopReceived(m_cameraState.fstop, m_cameraState.stopUnits)
		m_cameraControlToUIDelegate?.onApertureNormalisedReceived(m_cameraState.apertureNormalised)
		updateIrisAndShutterControl()
        updateRecordingEnabled()
		
		if (m_sensorGainIsISO) {
			let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
			if let isoIndex: Int = isoValues.firstIndex(of: m_cameraState.ISO) {
				m_cameraControlToUIDelegate?.onISOReceived(isoIndex)
			}
		} else {
			if let gainValues = VideoConfig.gainValues[m_cameraState.cameraModel] ?? VideoConfig.gainValues[CameraModel.Unknown] {
				if gainValues.contains(m_cameraState.gain) {
					m_cameraControlToUIDelegate?.onGainReceived(m_cameraState.gain)
				}
			}
		}
    }

    public func onSlateViewLoaded() {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_slateToUIDelegate?.onReelReceived(Int16(m_cameraState.reel), m_cameraState.reelEditable)
			m_slateToUIDelegate?.onSceneTagsReceived(Int(m_cameraState.sceneTag.rawValue), Int(m_cameraState.locationTag.rawValue), Int(m_cameraState.timeTag.rawValue))
			m_slateToUIDelegate?.onSceneReceived(m_cameraState.scene)
			m_slateToUIDelegate?.onTakeReceived(Int8(m_cameraState.takeNumber), Int(m_cameraState.takeTag.rawValue))
			m_slateToUIDelegate?.onSlateForNameReceived(m_cameraState.slateName)
			m_slateToUIDelegate?.onGoodTakeReceived(m_cameraState.goodTake)
			m_slateToUIDelegate?.setSlateForNextClip(m_cameraState.slateType == CCUPacketTypes.MetadataSlateForType.NextClip)
            m_slateToUIDelegate?.onReelModifiable(m_cameraState.transportInfo.slots.allSatisfy({$0.active == false}))
		}
    }

    public func onTransportViewLoaded() {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			let times = m_cameraState.slots.map{ $0.displayedRemainingRecordTime }
			if (times.count > 0) {
				m_recordControlToUIDelegate?.onRecordTimeRemainingReceived(times)
			}
			m_recordControlToUIDelegate?.setRecordingError(m_cameraState.hasRecordingError)
			m_recordControlToUIDelegate?.onActiveDisksReceived(m_cameraState.transportInfo.slots.map{ $0.active })
			m_recordControlToUIDelegate?.onTimelapseReceived(m_cameraState.transportInfo.timelapseRecording)
			m_recordControlToUIDelegate?.onTimecodeReceived(m_cameraState.timecode)
			let transportMode = m_cameraState.transportInfo.transportMode
			let playbackSpeed = m_cameraState.transportInfo.speed
			m_recordControlToUIDelegate?.setRecording(transportMode == CCUPacketTypes.MediaTransportMode.Record)
			
			if transportMode == CCUPacketTypes.MediaTransportMode.Play {
				m_recordControlToUIDelegate?.showPlaybackView(for: m_cameraState.slateName, at: Int(playbackSpeed))
			} else {
				m_recordControlToUIDelegate?.hidePlaybackView()
			}
		}
    }

    public func getPeripheralName() -> String {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			return m_btPeripheralInterface?.getPeripheral()?.name ?? "Blackmagic Design Camera"
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            return m_usbPtpInterface?.getDevice()?.getName() ?? "Blackmagic Design Camera"
        }
    #endif
		
		return "No camera connected"
    }
	
	public func getCameraModel() -> CameraModel {
		return m_cameraState.cameraModel
	}

    // InitialConnectionFromUIDelegate methods
    public func attemptConnection(to identifier: UUID) {
		m_userInstigatedConnection = true
        m_btConnectionManager.attemptConnection(to: identifier)
    }
	
#if os(OSX)
    public func connectToPTPDevice(to usbBulkDevice: USBControl.USBBulkDevice) {
        if (m_usbConnectionManager.openDevice(device: usbBulkDevice)) {
            if ((m_usbPtpInterface?.openSession(forceClosePreviousSessionIfPresent: true))!) {
                m_initialConnectionToUIDelegate?.transitionToCameraControl()
            }
            else {
                m_initialConnectionToUIDelegate?.onConnectionFailed()
            }
        }
    }
#endif

    public func disconnect() {
		// Disconnect from any connections
		// Bluetooth
        let peripheral: CBPeripheral? = m_btPeripheralInterface?.getPeripheral()
        if peripheral != nil {
            m_btConnectionManager.disconnect(from: peripheral!)
            m_btPeripheralInterface = nil
            m_cameraState.hasRecordingError = false
            m_connectionStatus = ConnectionStatusFlags.kNone
        }

    #if os(OSX)
        // USB
        if (m_usbPtpInterface != nil) {
            m_usbConnectionManager.closeDevice()
        }
    #endif
    }

    public func refreshDeviceList() {
		m_btConnectionManager.refreshScan()
		
    #if os(OSX)
        m_initialConnectionToUIDelegate?.updateDiscoveredUSBPTPDevices(m_usbConnectionManager.getDiscoveredUSBPTPDevices())
    #endif
    }

    // BluetoothConnectionManagerDelegate methods
    public func updateDiscoveredPeripheralList(_ peripheralList: [DiscoveredPeripheral]) {
        m_initialConnectionToUIDelegate?.updateDiscoveredPeripheralList(peripheralList)
    }

    public func connectedToPeripheral(_ peripheral: CBPeripheral) {
        m_btPeripheralInterface = PeripheralInterface(peripheral: peripheral)
        m_btPeripheralInterface?.setDelegate(self)
		m_btPeripheralInterface?.setPowerCharacteristic(m_userInstigatedConnection)
        m_connectionStatus |= ConnectionStatusFlags.kConnected

        if let peripheralName = peripheral.name {
            Logger.Log("Connected to \(String(describing: peripheralName))")
        }
		
		updateAllUI()
    }
    
    public func isConnected() -> Bool {
        return m_connectionStatus & ConnectionStatusFlags.kConnected != 0
    }

    public func onConnectionLost() {
        m_connectionStatusDelegate?.onConnectionLost()
        m_connectionStatus = ConnectionStatusFlags.kNone
		m_userInstigatedConnection = false
    }
	
    public func onConnectionFailed(with error: Error?) {
		processConnectionError(with: error)
    }

    public func onDisconnected(with error: Error?) {
		processConnectionError(with: error)

        m_btPeripheralInterface = nil
        m_connectionStatus = ConnectionStatusFlags.kNone
        m_connectionStatusDelegate?.onDisconnection()
    }

    public func onReconnection() {
        m_connectionStatus |= ConnectionStatusFlags.kConnected
    }
	
	public func processConnectionError(with error: Error?) {
		var name = "this camera"
		var isPaired = false
		if let peripheralInterface = m_btPeripheralInterface {
			name = peripheralInterface.getPeripheral()?.name ?? name
			isPaired = peripheralInterface.isPaired()
		}
		
		let haveError = error != nil
		let connectionAttemptInProgress = m_connectionStatus != ConnectionStatusFlags.kNone
		if haveError {
			if !isPaired {
				let nsError = error! as NSError
				let errorType: BluetoothConnectionManager.ErrorType = (domain: nsError.domain, code: nsError.code)
				let clearDeviceError = BluetoothConnectionManager.kPairingFailClearDeviceErrors.contains { $0 == errorType }
				let tryAgainError = BluetoothConnectionManager.kPairingFailTryAgainErrors.contains { $0 == errorType }
				
            #if os(iOS)
                if clearDeviceError {
                    m_initialConnectionToUIDelegate?.onPairingFailed(name, resolution: BluetoothPairingFailureType.ClearDevice)
                } else if tryAgainError {
                    m_initialConnectionToUIDelegate?.onPairingFailed(name, resolution: BluetoothPairingFailureType.TryAgain)
                }
            #else
                m_initialConnectionToUIDelegate?.onPairingFailed(name, resolution: BluetoothPairingFailureType.Unspecified)
            #endif
			}
		}
		else if connectionAttemptInProgress {
        #if os(iOS)
            m_initialConnectionToUIDelegate?.onPairingFailed(name, resolution: BluetoothPairingFailureType.TryAgain)
        #else
            m_initialConnectionToUIDelegate?.onPairingFailed(name, resolution: BluetoothPairingFailureType.Unspecified)
        #endif
		}
	}

    // LocationServicesDelegate methods
    public func onLocationReceived(_ latitide: UInt64, _ longitude: UInt64) {
        m_ccuEncoder.writeLocation(latitide, longitude)
    }

    public func onLocationFailed(_ error: Error) {
        // On macOS, a wi-fi connection needs to be active, or location discovery will fail.
        Logger.LogError(error.localizedDescription)
    }

    // PacketReceivedDelegate methods
	public func onSuccessfulPairing(_ cameraName: String) {
        m_connectionStatus |= ConnectionStatusFlags.kPaired
        m_initialConnectionToUIDelegate?.onSuccessfulPairing(cameraName)
    }

    public func onTimecodePacketReceived(_ data: Data?) {
        m_ccuDecoder.readTimecodePacket(data)
    }

    public func onCameraStatusPacketReceived(_ data: Data?) {
        let cameraStatus: UInt8 = m_ccuDecoder.readCameraStatus(data)
        Logger.Log("Camera Status: \(cameraStatus)") 
        let cameraIsOn = cameraStatus & CameraStatus.Flags.CameraPowerFlag != 0
        let cameraIsReady = cameraStatus & CameraStatus.Flags.CameraReadyFlag != 0
        let cameraWasReady = m_connectionStatus & ConnectionStatusFlags.kCameraReady != 0
        let alreadyReceivedInitalPayload = m_connectionStatus & ConnectionStatusFlags.kInitialPayloadReceived != 0
        
        if cameraIsReady {
            if !alreadyReceivedInitalPayload {
                onInitialPayloadReceived()
            }
            if !cameraWasReady {
                m_connectionStatusDelegate?.onCameraReady()
            }
            m_connectionStatus |= ConnectionStatusFlags.kInitialPayloadReceived
            m_connectionStatus |= ConnectionStatusFlags.kCameraReady
            m_connectionStatus |= ConnectionStatusFlags.kPower
        } else if cameraIsOn {
            m_connectionStatus |= ConnectionStatusFlags.kPower
            m_connectionStatusDelegate?.onCameraPoweredOn()
        } else {
            m_connectionStatus &= ~ConnectionStatusFlags.kCameraReady
            m_connectionStatus &= ~ConnectionStatusFlags.kPower

			// If the camera powered off, and we're running in the background, then disconnect.
			var runningInBackground = false
        #if os(iOS)
            let app = UIApplication.shared
            runningInBackground = (app.applicationState == UIApplication.State.background)
        #endif

			if runningInBackground {
				disconnect()
			} else {
				// Otherwise, notify the UI
				m_connectionStatusDelegate?.onCameraPoweredOff()
			}
        }
    }

    public func onCCUPacketReceived(_ data: Data?) {
        m_ccuDecoder.readCCUPacket(data)
    }

    public func onCameraModelPacketReceived(_ data: Data?) {
        m_ccuDecoder.readCameraModelPacket(data)
    }

    public func onReadValueErrorReported(_ error: Error) {
        if let peripheral = m_btPeripheralInterface?.getPeripheral() {
            m_btConnectionManager.disconnect(from: peripheral, with: error)
        }
    }

    public func onWriteValueErrorReported(_ error: Error) {
        if let peripheral = m_btPeripheralInterface?.getPeripheral() {
            m_btConnectionManager.disconnect(from: peripheral, with: error)
        }
    }

    public func onCameraNameChanged(_ cameraName: String) {
        m_cameraNameDelegate?.onCameraNameChanged(cameraName)
    }

    func onInitialPayloadReceived() {
        m_initialConnectionToUIDelegate?.transitionToCameraControl()
    }

    public func onProtocolVersionReceived(_ peripheral: CBPeripheral, _ data: Data?) {
        var cameraVersionNumbers: [String] = []
        if let data: Data = data {
            let optionalProtocolVersion = String(data: data, encoding: .utf8)
            if let protocolVersion: String = optionalProtocolVersion {
                cameraVersionNumbers = protocolVersion.components(separatedBy: ".")
            }
        }

        verifyVersionNumbersAreCompatible(peripheral, cameraVersionNumbers)
    }

    fileprivate func verifyVersionNumbersAreCompatible(_ peripheral: CBPeripheral, _ versionNumbers: [String]) {
        let appMajorVersion = ProtocolVersionNumber.kMajor
        let cameraMajorVersion = versionNumbers.count > 0 ? (versionNumbers[0].toInt() ?? -1) : -1
        let compatibilityVerified = cameraMajorVersion == appMajorVersion

        if compatibilityVerified {
            m_connectionStatus |= ConnectionStatusFlags.kVersionsVerified
        } else {
            disconnect()
            refreshDeviceList()
            let cameraName = peripheral.name ?? "Blackmagic Design Camera"
            m_initialConnectionToUIDelegate?.onIncompatibleProtocolVersion(cameraName, cameraVersion: cameraMajorVersion, appVersion: appMajorVersion)
        }
    }

    // PacketEncodedDelegate methods
    public func onCCUPacketEncoded(_ data: Data) {
        m_btPeripheralInterface?.sendPacket(data, BMDCameraServices.kMainService, BMDCameraCharacteristics.kOutgoingCCU)
    }

    public func onPowerPacketEncoded(_ data: Data) {
        m_btPeripheralInterface?.sendPacket(data, BMDCameraServices.kMainService, BMDCameraCharacteristics.kCameraStatus)
    }

    // PacketDecodedDelegate methods
    public func onCameraSpecificationReceived(_ cameraModel: CameraModel) {
        m_cameraState.cameraModel = cameraModel
        
        m_cameraControlToUIDelegate?.onCameraSpecificationReceived(cameraModel)
    }
	
	public func onWhiteBalanceKelvinReceived(_ whiteBalance: Int16) {
		onWhiteBalanceReceived(whiteBalance, m_cameraState.tint)
	}
	
	public func onWhiteBalanceTintReceived(_ tint: Int16) {
		onWhiteBalanceReceived(m_cameraState.whiteBalance, tint)
	}
    
    public func onWhiteBalanceReceived(_ whiteBalance: Int16, _ tint: Int16) {
        m_cameraState.whiteBalance = whiteBalance
        m_cameraState.tint = tint

        if m_isSuspended { return }
        
        let wasWhiteBalanceExpected = m_cameraState.expectedWhiteBalance.removeUpToExpectedValue(whiteBalance)
        let wasTintExpected = m_cameraState.expectedTint.removeUpToExpectedValue(tint)
        if !wasWhiteBalanceExpected || !wasTintExpected {
            let presetIndex = VideoConfig.GetWhiteBalancePresetFromValues(whiteBalance, tint)
            m_cameraControlToUIDelegate?.onWhiteBalanceReceived(whiteBalance, tint, presetIndex)
        }
    }

    public func onRecordingFormatReceived(_ recordingFormatData: CCUPacketTypes.RecordingFormatData) {
        let lastOffSpeedFrameRate = m_cameraState.recordingFormatData.offSpeedFrameRate
        let newOffSpeedFrameRate = recordingFormatData.offSpeedFrameRate
        let offSpeedEnabled = recordingFormatData.offSpeedEnabled
        m_cameraState.recordingFormatData = recordingFormatData
        m_cameraState.frameRateForShutterCalculations = recordingFormatData.offSpeedFrameRate

        if !offSpeedEnabled && lastOffSpeedFrameRate != 0 && lastOffSpeedFrameRate != newOffSpeedFrameRate {
            m_cameraState.recordingFormatData.offSpeedFrameRate = lastOffSpeedFrameRate
        }

        if m_isSuspended { return }
        
        let wasExpected = m_cameraState.expectedOffSpeedFrameRate.removeUpToExpectedValue(newOffSpeedFrameRate)
        if !wasExpected {
            m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(offSpeedEnabled, newOffSpeedFrameRate)
        }
    }
	
	public func onAutoExposureModeReceived(_ autoExposureMode: CCUPacketTypes.AutoExposureMode) {
		m_cameraState.autoExposureMode = autoExposureMode
		updateIrisAndShutterControl()
	}
	
	func updateIrisAndShutterControl() {
		let autoExposureMode = m_cameraState.autoExposureMode
		let manualIris = (autoExposureMode == CCUPacketTypes.AutoExposureMode.Manual) || (autoExposureMode == CCUPacketTypes.AutoExposureMode.Shutter)
		let manualShutter = (autoExposureMode == CCUPacketTypes.AutoExposureMode.Manual) || (autoExposureMode == CCUPacketTypes.AutoExposureMode.Iris)
		let lensAttached = (m_cameraState.fstop > 0) && LensConfig.IsApertureNormalisedValid(m_cameraState.apertureNormalised)
		
		m_cameraControlToUIDelegate?.setIrisControlEnabled(manualIris && lensAttached)
		m_cameraControlToUIDelegate?.setShutterControlEnabled(manualShutter)
	}

	public func onApertureFstopReceived(_ fstop: Float, _ stopUnits: LensConfig.ApertureUnits) {
		m_cameraState.fstop = fstop
		m_cameraState.stopUnits = stopUnits

		if m_isSuspended { return }

		m_cameraControlToUIDelegate?.onApertureFstopReceived(fstop, stopUnits)
		updateIrisAndShutterControl()
	}

	public func onApertureNormalisedReceived(_ apertureNormalised: Float) {
		m_cameraState.apertureNormalised = apertureNormalised

		if m_isSuspended { return }

		var wasExpected: Bool
		if LensConfig.IsApertureNormalisedValid(apertureNormalised)
		{
			wasExpected = m_cameraState.expectedApertureNormalisedx100.removeUpToExpectedValue(Int8(apertureNormalised * 100))
		}
		else
		{
			wasExpected = false
			// Receiving invalid aperture normalised value indicates the lens is removed.
			// Clear expectedApertureNormalisedx100, so that its m_expectedValueNotReceivedCallback function won't be called.
			m_cameraState.expectedApertureNormalisedx100.clearExpectedValues()
		}

		if !wasExpected {
			m_cameraControlToUIDelegate?.onApertureNormalisedReceived(apertureNormalised)
			updateIrisAndShutterControl()
		}
	}

    public func onExposureReceived(_ exposure: Int32) {
    }
	
	public func onShutterSpeedReceived(_ shutterSpeed: Int32) {
		m_shutterValueIsAngle = false
		let wasExpected = m_cameraState.expectedShutterSpeed.removeUpToExpectedValue(shutterSpeed)
		m_cameraState.shutterSpeed = shutterSpeed
		
		if m_isSuspended { return }
		
		if !wasExpected {
			m_cameraControlToUIDelegate?.onShutterSpeedReceived(m_cameraState.shutterSpeed)
		}
	}
	
	public func onShutterAngleReceived(_ shutterAngleX100: Int32) {
		m_shutterValueIsAngle = true
		let wasExpected = m_cameraState.expectedShutterAngle.removeUpToExpectedValue(shutterAngleX100)
		m_cameraState.shutterAngle = Double(shutterAngleX100) / 100.0
		
		if m_isSuspended { return }
		
		if !wasExpected {
			m_cameraControlToUIDelegate?.onShutterAngleReceived(m_cameraState.shutterAngle)
		}
	}

    public func onISOReceived(_ iso: Int) {
		let wasExpected = m_cameraState.expectedISOValue.removeUpToExpectedValue(Int32(iso))
		
		m_sensorGainIsISO = true
		m_cameraState.ISO = iso
        
        if m_isSuspended { return }
		
		if !wasExpected {
			let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
			if let isoIndex: Int = isoValues.firstIndex(of: iso) {
				m_cameraControlToUIDelegate?.onISOReceived(isoIndex)
			}
		}
    }
	
	public func onGainReceived(_ decibels: Int) {
		m_sensorGainIsISO = false
		m_cameraState.gain = decibels
		
		if m_isSuspended { return }
		
		m_cameraControlToUIDelegate?.onGainReceived(decibels)
	}

#if os(OSX)
	public func onDeviceInfoReceived(_ deviceInfo: PTPDeviceInfo) {
		m_cameraState.cameraModel = CameraModel.from(name: deviceInfo.m_model)
        m_cameraControlToUIDelegate?.onCameraSpecificationReceived(m_cameraState.cameraModel)
	}
#endif

	public func onNDFilterStopReceived(_ stop: Float, _ displayMode: VideoConfig.NDFilterDisplayMode) {
        m_cameraState.ndFilterStop = stop
		m_cameraState.ndFilterDisplayMode = displayMode

		if m_isSuspended { return }
		
		m_cameraControlToUIDelegate?.onNDFilterStopReceived(stop, displayMode)
    }

	public func onReelReceived(_ reelNumber: Int16, _ editable: Bool) {
        m_cameraState.reel = Int(reelNumber)
		m_cameraState.reelEditable = editable
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onReelReceived(reelNumber, editable)
    }

    public func onSceneTagsReceived(_ sceneTag: CCUPacketTypes.MetadataSceneTag, _ locationTag: CCUPacketTypes.MetadataLocationTypeTag, _ timeTag: CCUPacketTypes.MetadataDayNightTag) {
        m_cameraState.sceneTag = sceneTag
        m_cameraState.locationTag = locationTag
        m_cameraState.timeTag = timeTag
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onSceneTagsReceived(Int(sceneTag.rawValue), Int(locationTag.rawValue), Int(timeTag.rawValue))
    }

    public func onSceneReceived(_ scene: String) {
        m_cameraState.scene = scene
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onSceneReceived(scene)
    }

    public func onTakeReceived(_ takeNumber: Int8, _ takeTag: CCUPacketTypes.MetadataTakeTag) {
        m_cameraState.takeNumber = Int(takeNumber)
        m_cameraState.takeTag = takeTag
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onTakeReceived(takeNumber, Int(takeTag.rawValue))
    }

    public func onGoodTakeReceived(_ goodTake: Bool) {
        m_cameraState.goodTake = goodTake
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onGoodTakeReceived(goodTake)
    }

	public func onSlateForNameReceived(_ slateForName: String) {
        m_cameraState.slateName = slateForName
        
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.onSlateForNameReceived(slateForName)
        m_recordControlToUIDelegate?.updateClipName(slateForName)
    }

    public func onSlateForTypeReceived(_ slateForType: CCUPacketTypes.MetadataSlateForType) {
        m_cameraState.slateType = slateForType
        if m_isSuspended { return }
        
        m_slateToUIDelegate?.setSlateForNextClip(slateForType == CCUPacketTypes.MetadataSlateForType.NextClip)
    }
	
	public func onBatteryLevelReceived(_ percentage: UInt8) {

	}

    public func onTimecodeSourceReceived(_ source: CCUPacketTypes.DisplayTimecodeSource) {
        m_cameraState.timecodeSource = source
    }

	public func onRecordingResolutionReceived(_ width: Int16, _ height: Int16) {
		m_cameraState.recordingFormatData.width = width
		m_cameraState.recordingFormatData.height = height
	}
	
	public func onOffSpeedFrameRateReceived(_ offSpeedFrameRate: Int16) {
		m_cameraState.recordingFormatData.offSpeedFrameRate = offSpeedFrameRate
		m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(m_cameraState.recordingFormatData.offSpeedEnabled, m_cameraState.recordingFormatData.offSpeedFrameRate)
	}
	
	public func onOffSpeedEnabledReceived(_ enabled: Bool) {
		m_cameraState.recordingFormatData.offSpeedEnabled = enabled
		m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(m_cameraState.recordingFormatData.offSpeedEnabled, m_cameraState.recordingFormatData.offSpeedFrameRate)
	}

    // OutgoingCameraControlFromUIDelegate methods

    // White Balance
    public func onWhiteBalanceIncremented() -> (whiteBalance: Int16, presetIndex: Int) {
        var newWhiteBalance: Int16 = m_cameraState.whiteBalance + VideoConfig.kWhiteBalanceStep
        if newWhiteBalance > VideoConfig.kWhiteBalanceMax {
            newWhiteBalance = VideoConfig.kWhiteBalanceMin
        }

        let presetIndex: Int = onWhiteBalanceChanged(newWhiteBalance)
        return (newWhiteBalance, presetIndex)
    }

    public func onWhiteBalanceDecremented() -> (whiteBalance: Int16, presetIndex: Int) {
        var newWhiteBalance: Int16 = m_cameraState.whiteBalance - VideoConfig.kWhiteBalanceStep
        if newWhiteBalance < VideoConfig.kWhiteBalanceMin {
            newWhiteBalance = VideoConfig.kWhiteBalanceMax
        }

        let presetIndex: Int = onWhiteBalanceChanged(newWhiteBalance)
        return (newWhiteBalance, presetIndex)
    }

    public func onWhiteBalanceChanged(_ whiteBalance: Int16) -> Int {
        m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(whiteBalance)
        m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(m_cameraState.tint)
		
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeWhiteBalance(whiteBalance, m_cameraState.tint)
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeWhiteBalance(UInt16(whiteBalance))
        }
    #endif

        return VideoConfig.GetWhiteBalancePresetFromValues(whiteBalance, m_cameraState.tint)
    }

    // Tint
    public func onTintIncremented() -> (tint: Int16, presetIndex: Int) {
        var newTint = m_cameraState.tint + 1
        if newTint > VideoConfig.kTintMax {
            newTint = VideoConfig.kTintMin
        }

        let presetIndex: Int = onTintChanged(newTint)
        return (newTint, presetIndex)
    }

    public func onTintDecremented() -> (tint: Int16, presetIndex: Int) {
        var newTint = m_cameraState.tint - 1
        if newTint < VideoConfig.kTintMin {
            newTint = VideoConfig.kTintMax
        }

        let presetIndex: Int = onTintChanged(newTint)
        return (newTint, presetIndex)
    }

    public func onTintChanged(_ tint: Int16) -> Int {
        m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(m_cameraState.whiteBalance)
        m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(tint)
		
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeWhiteBalance(m_cameraState.whiteBalance, tint)
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeTint(Int8(tint))
        }
    #endif
		
        return VideoConfig.GetWhiteBalancePresetFromValues(m_cameraState.whiteBalance, tint)
    }

    // White Balance Presets
    public func onWhiteBalancePresetPressed(_ presetIndex: Int, _ currentlySelected: Bool, _ saveCustomValues: Bool) -> (whiteBalance: Int16, tint: Int16)? {
        if saveCustomValues {
            m_cameraState.customWhiteBalance = m_cameraState.whiteBalance
            m_cameraState.customTint = m_cameraState.tint
        }

        if !currentlySelected {
            if presetIndex < VideoConfig.kWhiteBalancePresets.count {
                let whiteBalancePreset: VideoConfig.WhiteBalancePreset = VideoConfig.kWhiteBalancePresets[presetIndex]

                m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(m_cameraState.whiteBalance)
                m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(whiteBalancePreset.whiteBalance)
                m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(m_cameraState.tint)
                m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(whiteBalancePreset.tint)

				if getCurrentTransportControl() == TransportControl.Bluetooth {
					m_ccuEncoder.writeWhiteBalance(whiteBalancePreset.whiteBalance, whiteBalancePreset.tint)
				}
				
            #if os(OSX)
                if getCurrentTransportControl() == TransportControl.USB {
                    _ = m_usbPtpInterface?.writeWhiteBalance(UInt16(whiteBalancePreset.whiteBalance))
                    _ = m_usbPtpInterface?.writeTint(Int8(whiteBalancePreset.tint))
                }
            #endif
				
                return (whiteBalancePreset.whiteBalance, whiteBalancePreset.tint)
            } else {
                onAutoWhiteBalancePressed()
            }
        } else {
            m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(m_cameraState.whiteBalance)
            m_cameraState.expectedWhiteBalance.addExpectedValueAllowingDuplicates(m_cameraState.customWhiteBalance)
            m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(m_cameraState.tint)
            m_cameraState.expectedTint.addExpectedValueAllowingDuplicates(m_cameraState.customTint)

			if getCurrentTransportControl() == TransportControl.Bluetooth {
				m_ccuEncoder.writeWhiteBalance(m_cameraState.customWhiteBalance, m_cameraState.customTint)
			}
			
        #if os(OSX)
            if getCurrentTransportControl() == TransportControl.USB {
                _ = m_usbPtpInterface?.writeWhiteBalance(UInt16(m_cameraState.customWhiteBalance))
                _ = m_usbPtpInterface?.writeTint(Int8(m_cameraState.customTint))
            }
        #endif
			
            return (m_cameraState.customWhiteBalance, m_cameraState.customTint)
        }

        return nil
    }

    public func onAutoWhiteBalancePressed() {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeAutoWhiteBalance()
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.enableAutoWhiteBalance()
        }
    #endif
    }

    // Off-Speed Frame Rate
    public func onOffSpeedFrameRateToggled(_ offSpeedEnabled: Bool) {
        m_cameraState.recordingFormatData.offSpeedEnabled = offSpeedEnabled
		
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeRecordingFormat(m_cameraState.recordingFormatData)
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeOffSpeedEnabled(offSpeedEnabled)
        }
    #endif
    }

    public func onOffSpeedFrameRateIncremented() -> Int16 {
        let frameRateMin = VideoConfig.kOffSpeedFrameRateMin[m_cameraState.cameraModel] ?? VideoConfig.kOffSpeedFrameRateMin[CameraModel.Unknown]!
        let frameRateMax = VideoConfig.kOffSpeedFrameRateMax[m_cameraState.cameraModel] ?? VideoConfig.kOffSpeedFrameRateMax[CameraModel.Unknown]!
        var newOffSpeedFrameRate = m_cameraState.recordingFormatData.offSpeedFrameRate + 1
        
        if newOffSpeedFrameRate > frameRateMax {
            newOffSpeedFrameRate = frameRateMin
        }

        onOffSpeedFrameRateChanged(newOffSpeedFrameRate)
        return newOffSpeedFrameRate
    }

    public func onOffSpeedFrameRateDecremented() -> Int16 {
        let frameRateMin = VideoConfig.kOffSpeedFrameRateMin[m_cameraState.cameraModel] ?? VideoConfig.kOffSpeedFrameRateMin[CameraModel.Unknown]!
        let frameRateMax = VideoConfig.kOffSpeedFrameRateMax[m_cameraState.cameraModel] ?? VideoConfig.kOffSpeedFrameRateMax[CameraModel.Unknown]!
        var newOffSpeedFrameRate = m_cameraState.recordingFormatData.offSpeedFrameRate - 1
        
        if newOffSpeedFrameRate < frameRateMin {
            newOffSpeedFrameRate = frameRateMax
        }

        onOffSpeedFrameRateChanged(newOffSpeedFrameRate)
        return newOffSpeedFrameRate
    }

    public func onOffSpeedFrameRateChanged(_ frameRate: Int16) {
        var recordingFormatData = m_cameraState.recordingFormatData
        recordingFormatData.offSpeedFrameRate = frameRate
        let addedExpectedValue = m_cameraState.expectedOffSpeedFrameRate.addExpectedValue(frameRate)
        if addedExpectedValue {
			if getCurrentTransportControl() == TransportControl.Bluetooth {
				m_ccuEncoder.writeRecordingFormat(recordingFormatData)
			}
			
        #if os(OSX)
            if getCurrentTransportControl() == TransportControl.USB {
                _ = m_usbPtpInterface?.writeOffSpeedFrameRate(UInt32(frameRate))
            }
        #endif
        }
    }

    // Iris
	public func onApertureIncremented(_ currentApertureNormalised: Float) {
        if getCurrentTransportControl() == TransportControl.Bluetooth {
		    m_ccuEncoder.writeApertureOrdinalOffset(1, CCUPacketTypes.ApertureStepLength.EighthStop);
        }
        #if os(OSX)
            if getCurrentTransportControl() == TransportControl.USB {
                _ = m_usbPtpInterface?.incrementAperture(currentApertureNormalised)
            }
        #endif
	}

	public func onApertureDecremented(_ currentApertureNormalised: Float) {
        if getCurrentTransportControl() == TransportControl.Bluetooth {
		    m_ccuEncoder.writeApertureOrdinalOffset(-1, CCUPacketTypes.ApertureStepLength.EighthStop);
        }
        #if os(OSX)
            if getCurrentTransportControl() == TransportControl.USB {
                _ = m_usbPtpInterface?.decrementAperture(currentApertureNormalised)
            }
        #endif
	}

	public func onApertureNormalisedChanged(_ apertureNormalised: Float) {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			let addedExpectedValue = m_cameraState.expectedApertureNormalisedx100.addExpectedValue(Int8(apertureNormalised * 100))
			if addedExpectedValue {
				let ccuApertureNormalised = CCUPacketTypes.CCUFixedFromFloat(apertureNormalised)
				m_ccuEncoder.writeApertureNormalised(ccuApertureNormalised)
			}
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            let addedExpectedValue = m_cameraState.expectedApertureNormalisedx100.addExpectedValue(Int8(apertureNormalised * 100))
            if addedExpectedValue {
                _ = m_usbPtpInterface?.writeApertureNormalised(apertureNormalised)
            }
        }
    #endif
	}

    public func getApertureUnits() -> LensConfig.ApertureUnits {
        return m_cameraState.stopUnits
    }

    // Shutter
    public func onShutterIncremented() -> Double {
        let nextShutterValue = getNextPresetShutterValue()
        onShutterChanged(nextShutterValue)

        return nextShutterValue
    }

    public func onShutterDecremented() -> Double {
        let prevShutterValue = getPrevPresetShutterValue()
        onShutterChanged(prevShutterValue)

        return prevShutterValue
    }

    func getNextPresetShutterValue() -> Double {
		if (m_shutterValueIsAngle)	{
			for value in VideoConfig.kShutterAngles {
				if value > m_cameraState.shutterAngle {
					return value
				}
			}
			
			return VideoConfig.kShutterAngles[0]
		} else {
			for value in VideoConfig.kShutterSpeeds {
				if value > m_cameraState.shutterSpeed {
					return Double(value)
				}
			}
			return Double(VideoConfig.kShutterSpeeds[0])
		}
    }

    func getPrevPresetShutterValue() -> Double {
		if (m_shutterValueIsAngle)	{
			for value in VideoConfig.kShutterAngles.reversed() {
				if value < m_cameraState.shutterAngle {
					return value
				}
			}
			return VideoConfig.kShutterAngles.last!
		} else {
			for value in VideoConfig.kShutterSpeeds.reversed() {
				if value < m_cameraState.shutterSpeed {
					return Double(value)
				}
			}
			return Double(VideoConfig.kShutterSpeeds.last!)
		}
    }

    public func onShutterChanged(_ shutterValue: Double) {
		if (m_shutterValueIsAngle)	{
			let shutterAngleX100 = Int32(shutterValue * 100.0)
			let addedExpectedValue = m_cameraState.expectedShutterAngle.addExpectedValue(shutterAngleX100)
			if addedExpectedValue {
				if getCurrentTransportControl() == TransportControl.Bluetooth {
					m_ccuEncoder.writeShutterAngle(shutterAngleX100)
				}
				
            #if os(OSX)
                if getCurrentTransportControl() == TransportControl.USB {
                    _ = m_usbPtpInterface?.writeShutterAngle(UInt16(shutterAngleX100))
                }
            #endif
			}
		} else {
			let shutterSpeed = Int32(shutterValue)
			let addedExpectedValue = m_cameraState.expectedShutterSpeed.addExpectedValue(shutterSpeed)
			if addedExpectedValue {
				if getCurrentTransportControl() == TransportControl.Bluetooth {
					m_ccuEncoder.writeShutterSpeed(shutterSpeed)
				}
				
            #if os(OSX)
                if getCurrentTransportControl() == TransportControl.USB {
                    _ = m_usbPtpInterface?.writeShutterSpeed(UInt16(shutterSpeed))
                }
            #endif
			}
		}
    }

    // ISO
	public func onISOIncremented() -> Int {
		let nextISOIndex = getNextISOIndex()
		onISOChanged(nextISOIndex)
		
		return nextISOIndex
	}
	
	public func onISODecremented() -> Int {
		let prevISOIndex = getPrevISOIndex()
		onISOChanged(prevISOIndex)
		
		return prevISOIndex
	}
	
	func getNextISOIndex() -> Int {
		let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!

		if let isoIndex = isoValues.firstIndex(of: m_cameraState.ISO) {
			let newISOIndex = isoIndex + 1
			if newISOIndex < isoValues.count {
				return newISOIndex
			}
		}
		
		return 0
	}
	
	func getPrevISOIndex() -> Int {
		let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
		
		if let isoIndex = isoValues.firstIndex(of: m_cameraState.ISO) {
			let newISOIndex = isoIndex - 1
			if newISOIndex > 0 {
				return newISOIndex
			}
		}
		
		return isoValues.count - 1
	}

    public func onSensorGainChanged(_ isoIndex: Int) {
		let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
        let iso = isoValues[isoIndex]
        if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeSensorGain(iso)
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeExposureIndex(UInt16(iso))
        }
    #endif
    }
	
	public func onISOChanged(_ isoIndex: Int) {
		let isoValues = VideoConfig.kISOValues[m_cameraState.cameraModel] ?? VideoConfig.kISOValues[CameraModel.Unknown]!
		let iso = isoValues[isoIndex]
		let addedExpectedValue = m_cameraState.expectedISOValue.addExpectedValue(Int32(iso))
		if addedExpectedValue {
			if getCurrentTransportControl() == TransportControl.Bluetooth {
				m_ccuEncoder.writeISO(iso)
			}
			
        #if os(OSX)
            if getCurrentTransportControl() == TransportControl.USB {
                _ = m_usbPtpInterface?.writeExposureIndex(UInt16(iso))
            }
        #endif
		}
	}

	public func onGainSet(_ gain: Decibels) {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeGain(gain)
		}
	}

	// ND Filter
	public func onNDFilterIncremented() -> Float {
		let forward = true
		let next = getNextNDFilterStop(forward)
		onNDFilterStopChanged(next, m_cameraState.ndFilterDisplayMode)
		
		return next
	}
	
	public func onNDFilterDecremented() -> Float {
		let forward = false
		let prev = getNextNDFilterStop(forward)
		onNDFilterStopChanged(prev, m_cameraState.ndFilterDisplayMode)
		
		return prev
	}
	
	func getNextNDFilterStop(_ forward: Bool) -> Float {
		let stops = VideoConfig.kAvailableNDFilterStops
		if let index = stops.firstIndex(of: m_cameraState.ndFilterStop) {
			var newIndex = forward ? index + 1 : index - 1
			newIndex = newIndex % stops.count
			newIndex = (newIndex >= 0) ? newIndex : newIndex + stops.count
			return stops[newIndex]
		}

        return 0.0
	}
	
	public func onNDFilterStopChanged(_ stop: Float, _ displayMode: VideoConfig.NDFilterDisplayMode) {
		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeNDFilterStop(CCUPacketTypes.CCUFixedFromFloat(stop), displayMode)
		}
		
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeNDFilter(CCUPacketTypes.CCUFixedFromFloat(stop))
        }
    #endif
	}

	public func onFocusPullIncremented() -> Int {
		let minPositiveFocusPullStep = 10
		
		///
		m_cameraState.focusPosition += minPositiveFocusPullStep
		let focusPos = m_cameraState.focusPosition
		///
		
		onFocusPullChanged(focusPos)
		
		return focusPos
	}
	
	public func onFocusPullDecremented() -> Int {
		let minNegativeFocusPullStep = -10
		
		///
		m_cameraState.focusPosition += minNegativeFocusPullStep
		let focusPos = m_cameraState.focusPosition
		///
		
		onFocusPullChanged(focusPos)
		
		return focusPos
	}
	
	public func onFocusPullChanged(_ focusPullStep: Int) {
        // lerp
        var focusDistanceLerped = Int32(Float(focusPullStep + 100) / 200 * 65535)
        if focusDistanceLerped < 100 { focusDistanceLerped = 100 } // cap to not hit the edges
        if focusDistanceLerped > 65435 { focusDistanceLerped = 65435 } // cap to not hit the edges
        
    #if os(OSX)
        if getCurrentTransportControl() == TransportControl.USB {
            _ = m_usbPtpInterface?.writeFocusPosition(focusDistanceLerped)
        }
    #endif
        if getCurrentTransportControl() == TransportControl.Bluetooth {
            m_ccuEncoder.writeFocusPosition(focusDistanceLerped)
        }
	}

    // OutgoingSlateToCameraDelegate methods
    public func onReelIncremented() {
        let reel = m_cameraState.reel + 1
        if reel <= 999 {
			m_ccuEncoder.writeReel(Int16(reel), m_cameraState.reelEditable)
        }
    }

    public func onReelDecremented() {
        let reel = m_cameraState.reel - 1
        if reel > 0 {
			m_ccuEncoder.writeReel(Int16(reel), m_cameraState.reelEditable)
        }
    }

    public func onSceneTagSelected(sceneTagIndex: Int) {
        if let sceneTag = CCUPacketTypes.MetadataSceneTag(rawValue: Int8(sceneTagIndex)) {
            m_ccuEncoder.writeSceneTags(sceneTag, m_cameraState.locationTag, m_cameraState.timeTag)
        }
    }

    public func onLocationTagSelected(locationTagIndex: Int) {
        if let locationTag = CCUPacketTypes.MetadataLocationTypeTag(rawValue: UInt8(locationTagIndex)) {
            m_ccuEncoder.writeSceneTags(m_cameraState.sceneTag, locationTag, m_cameraState.timeTag)
        }
    }

    public func onTimeTagSelected(timeTagIndex: Int) {
        if let timeTag = CCUPacketTypes.MetadataDayNightTag(rawValue: UInt8(timeTagIndex)) {
            m_ccuEncoder.writeSceneTags(m_cameraState.sceneTag, m_cameraState.locationTag, timeTag)
        }
    }

    public func onSceneIncremented() {
        let newString = StringFunctions.IncrementSceneString(m_cameraState.scene)
        m_ccuEncoder.writeScene(newString)
    }

    public func onSceneDecremented() {
        let newString = StringFunctions.DecrementSceneString(m_cameraState.scene)
        m_ccuEncoder.writeScene(newString)
    }

    public func onTakeIncremented() {
        let take = (m_cameraState.takeNumber % 99) + 1
        m_ccuEncoder.writeTake(take, m_cameraState.takeTag)
    }

    public func onTakeDecremented() {
        let take = m_cameraState.takeNumber - 1
        if take > 0 {
            m_ccuEncoder.writeTake(take, m_cameraState.takeTag)
        }
    }

    public func onTakeTagSelected(takeTagIndex: Int) {
        if let takeTag = CCUPacketTypes.MetadataTakeTag(rawValue: Int8(takeTagIndex)) {
            m_ccuEncoder.writeTake(m_cameraState.takeNumber, takeTag)
        }
    }

    public func onGoodTakeToggled(_ goodTake: Bool) {
        m_ccuEncoder.writeGoodTake(goodTake)
    }

    // OutgoingPowerFromUIDelegate methods
    public func onPowerOff() {
        let turnPowerOn = false
        m_ccuEncoder.writePower(turnPowerOn)
    }

    // IncomingRecordingControlFromCameraDelegate methods
    func scheduleDiskInfoUpdate() {
        if m_isSuspended { return }
        
        m_diskTimer?.invalidate()
        m_diskTimer = Timer.scheduledTimer(timeInterval: kDiskInfoDelay, target: self, selector: #selector(updateDiskInfo), userInfo: nil, repeats: false)
    }

    @objc func updateDiskInfo() {
		let recording = m_cameraState.transportInfo.transportMode == CCUPacketTypes.MediaTransportMode.Record
        m_cameraState.hasRecordingError = recording ? m_cameraState.anyMediaWithError : m_cameraState.hasRecordingError // update record error (to remove the error) only when recording started to match camera's behavior
		m_recordControlToUIDelegate?.setRecording(recording)
		let times = m_cameraState.slots.map{ $0.displayedRemainingRecordTime }
		if (times.count > 0) {
			m_recordControlToUIDelegate?.onRecordTimeRemainingReceived(times)
		}
        m_recordControlToUIDelegate?.setRecordingError(m_cameraState.hasRecordingError)
        m_recordControlToUIDelegate?.onTimelapseReceived(m_cameraState.transportInfo.timelapseRecording)
        
		for slotIndex in 0 ..< m_cameraState.slots.count {
			let slotActive = m_cameraState.transportInfo.slots[slotIndex].active
			let recordTimeWarning: RecordTimeWarning = recording && slotActive ? m_cameraState.slots[slotIndex].recordTimeWarning : RecordTimeWarning.NoWarning
            m_recordControlToUIDelegate?.setRecordTimeWarning(recordTimeWarning, slotIndex)
        }
    }

	public func onTransportInfoReceived(_ info: TransportInfo) {
		m_cameraState.updateTransportInfo(info)
        
        if let cachedRemainingTime = cachedSlotData.recordTimeRemaining {
            onRecordTimeRemainingReceived(cachedRemainingTime.remainingRecordTimes, cachedRemainingTime.remainingTimesInMinutes)
        }

        if let cachedMediaStatus = cachedSlotData.mediaStatus {
            onMediaStatusReceived(cachedMediaStatus)
        }

        if m_isSuspended { return }
        
        scheduleDiskInfoUpdate()

        let activeDiskRecieved = m_cameraState.transportInfo.slots.map{ $0.active }

		m_recordControlToUIDelegate?.onActiveDisksReceived(activeDiskRecieved)
		m_cameraControlToUIDelegate?.onTransportModeReceived(info.transportMode)
        m_cameraControlToUIDelegate?.onOffSpeedFrameRateReceived(m_cameraState.recordingFormatData.offSpeedEnabled, m_cameraState.recordingFormatData.offSpeedFrameRate)
        
		if info.transportMode == CCUPacketTypes.MediaTransportMode.Play {
			m_recordControlToUIDelegate?.showPlaybackView(for: m_cameraState.slateName, at: Int(info.speed))
        } else {
            m_recordControlToUIDelegate?.hidePlaybackView()
        }

        updateRecordingEnabled()
		updateRecordTimeWarnings()

        m_slateToUIDelegate?.onReelModifiable(!activeDiskRecieved.contains(true))
    }

    private func updateRecordingEnabled(){
        var isRecordingEnabled = false
        let nonEmptyRemainingTimes = ["NoCard", "NoDrive", "FullCard", "FullDrive", "Full"].map({ String.Localized("Transport."+$0) })
        for slotIndex in 0 ..< m_cameraState.slots.count {
            let hasSpace =  !(nonEmptyRemainingTimes.contains(where: {$0 == m_cameraState.slots[slotIndex].remainingRecordTime}))
            let isActive = m_cameraState.transportInfo.slots[slotIndex].active
            isRecordingEnabled =  isRecordingEnabled || (hasSpace && isActive)
        }

        m_recordControlToUIDelegate?.recordingEnabled(isRecordingEnabled)
    }

    public func onTimecodeReceived(_ timecode: String) {
        m_cameraState.timecode = timecode
        
        if m_isSuspended { return }
        
        m_recordControlToUIDelegate?.onTimecodeReceived(timecode)
    }

    // Caching slot data in case remainingTime/MediaStatus CCU messages arrive before slots are initialized through transportInfo message received
    var cachedSlotData: (recordTimeRemaining: (remainingRecordTimes: [String], remainingTimesInMinutes: [Int16])?, mediaStatus: [CCUPacketTypes.MediaStatus]?) = (nil, nil)
    
	public func onMediaStatusReceived(_ statuses: [CCUPacketTypes.MediaStatus]) {
        cachedSlotData.mediaStatus = statuses;
		for slotIndex in 0 ..< min(m_cameraState.slots.count, statuses.count) {
			m_cameraState.slots[slotIndex].status = statuses[slotIndex]
		}

		m_cameraState.anyMediaWithError = m_cameraState.slots.contains(where: { $0.status == CCUPacketTypes.MediaStatus.RecordError })
        m_cameraState.hasRecordingError = m_cameraState.hasRecordingError ?  m_cameraState.hasRecordingError :  m_cameraState.anyMediaWithError // only enable error, don't disabled it onMediaStatusReceived
        updateRecordTimeRemainingStrings()
        scheduleDiskInfoUpdate()
        updateRecordingEnabled()
    }

	public func onRecordTimeRemainingReceived(_ remainingRecordTimes: [String], _ remainingTimesInMinutes: [Int16]) {
        cachedSlotData.recordTimeRemaining = (remainingRecordTimes, remainingTimesInMinutes)
		let slotCount = min(m_cameraState.slots.count, min(remainingRecordTimes.count, remainingTimesInMinutes.count))
		for slotIndex in 0 ..< slotCount {
			m_cameraState.slots[slotIndex].remainingRecordTime = remainingRecordTimes[slotIndex]
			m_cameraState.slots[slotIndex].remainingTimeInMinutes = remainingTimesInMinutes[slotIndex]
		}

        updateRecordingEnabled()
		updateRecordTimeWarnings()
	}

	let kLowSeverityThresholdMinutes = 5
	let kHighSeverityThresholdMinutes = 3

	func updateRecordTimeWarnings() {
		let slotCount = m_cameraState.slots.count
		if slotCount > 0 {
			var recordTimeWarnings = [RecordTimeWarning](repeating: RecordTimeWarning.NoWarning, count: slotCount)
			var minutesRemaining = [Int16](repeating: 0, count: slotCount)

			for slotIndex in 0 ..< slotCount {
				let slot = m_cameraState.slots[slotIndex]
				switch (slot.status) {
				case CCUPacketTypes.MediaStatus.None, CCUPacketTypes.MediaStatus.MountError:
					minutesRemaining[slotIndex] = 0
				default:
					minutesRemaining[slotIndex] = m_cameraState.slots[slotIndex].remainingTimeInMinutes
				}
			}
            
            var minutesRemainingTotal: Int16 = 0
            for slotIndex in 0 ..< slotCount {
                (minutesRemainingTotal, _) = minutesRemainingTotal.addingReportingOverflow(m_cameraState.slots[slotIndex].status != CCUPacketTypes.MediaStatus.None ? minutesRemaining[slotIndex] : 0)
            }

			for slotIndex in 0 ..< slotCount {
				if (minutesRemainingTotal < kHighSeverityThresholdMinutes) {
					recordTimeWarnings[slotIndex] = RecordTimeWarning.HighSeverity
				} else if (minutesRemainingTotal < kLowSeverityThresholdMinutes) {
					recordTimeWarnings[slotIndex] = RecordTimeWarning.LowSeverity
				}
			}

			let isMultiRecordMode = m_cameraState.transportInfo.getActiveSlotCount() > 1
			let lowestSeverityTimeWarning = recordTimeWarnings.min(by: { a, b in a.rawValue < b.rawValue }) ?? RecordTimeWarning.NoWarning
			for (slotIndex, slot) in m_cameraState.transportInfo.slots.enumerated() {
				m_cameraState.slots[slotIndex].recordTimeWarning = isMultiRecordMode && slot.active ? lowestSeverityTimeWarning : recordTimeWarnings[slotIndex]
			}

			updateRecordTimeRemainingStrings()
			scheduleDiskInfoUpdate()
		}
    }

	func updateRecordTimeRemainingStrings() {
		for slotIndex in 0 ..< m_cameraState.slots.count {
			let empty = m_cameraState.slots[slotIndex].status == CCUPacketTypes.MediaStatus.None
            let medium = m_cameraState.transportInfo.slots[slotIndex].medium
            let isDrive = medium == CCUPacketTypes.ActiveStorageMedium.SSD || medium == CCUPacketTypes.ActiveStorageMedium.USB
 			if (empty) {
				m_cameraState.slots[slotIndex].displayedRemainingRecordTime = isDrive ? String.Localized("Transport.NoDrive") : String.Localized("Transport.NoCard")
            }
            else if (m_cameraState.slots[slotIndex].remainingRecordTime == String.Localized("Transport.Full")) {
                m_cameraState.slots[slotIndex].displayedRemainingRecordTime = isDrive ? String.Localized("Transport.FullDrive") : String.Localized("Transport.FullCard")
            }
            else {
                m_cameraState.slots[slotIndex].displayedRemainingRecordTime = m_cameraState.slots[slotIndex].remainingRecordTime
            }
		}
	}

    // OutgoingRecordingControlFromUIDelegate methods
    public func onRecordPressed() {
		let isCurrentlyInPreview = m_cameraState.transportInfo.transportMode == CCUPacketTypes.MediaTransportMode.Preview
		var transportInfoCopy = m_cameraState.transportInfo
        transportInfoCopy.transportMode = isCurrentlyInPreview ? CCUPacketTypes.MediaTransportMode.Record : CCUPacketTypes.MediaTransportMode.Preview

		if getCurrentTransportControl() == TransportControl.Bluetooth {
			m_ccuEncoder.writeTransportPacket(transportInfoCopy)
		}
		
    #if os(OSX)
        if (m_usbPtpInterface != nil) {
            if (isCurrentlyInPreview) {
                _ = m_usbPtpInterface?.startRecord()
            }
            else {
                _ = m_usbPtpInterface?.stopRecord()
            }
        }
    #endif
    }

	public func onStillCapturePressed() {
    #if os(OSX)
        _ = m_usbPtpInterface?.stillCapture()
    #endif
	}
	
	public func onSlotPressed(_ index: Int) {
		if index < m_cameraState.slots.count {
			let status = m_cameraState.slots[index].status
			let slots = m_cameraState.transportInfo.slots
			let allow = index < slots.count && !slots[index].active && (status == CCUPacketTypes.MediaStatus.Ready || status == CCUPacketTypes.MediaStatus.RecordError)
            let isRecording = m_cameraState.transportInfo.transportMode == CCUPacketTypes.MediaTransportMode.Record
            if (allow && !isRecording) {
				for slotIndex in 0 ..< slots.count {
					m_cameraState.transportInfo.slots[slotIndex].active = slotIndex == index ? true : false
				}
				m_ccuEncoder.writeTransportPacket(m_cameraState.transportInfo)
			}
		}
	}
    
    public func onTimecodePressed() {
        if getCurrentTransportControl() == TransportControl.Bluetooth {
            let newTimecodeSource = m_cameraState.timecodeSource == CCUPacketTypes.DisplayTimecodeSource.Clip ? CCUPacketTypes.DisplayTimecodeSource.Timecode : CCUPacketTypes.DisplayTimecodeSource.Clip
            m_cameraState.timecodeSource = newTimecodeSource
            m_ccuEncoder.setTimecodeSource(newTimecodeSource)
        }
    }
}
