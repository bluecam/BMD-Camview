/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation

#if os(iOS)
import UIKit
#elseif os(OSX)
import Cocoa
#endif

extension String {
    public func toInt() -> Int? {
        return Int(self)
    }
}

extension String {
    public static func Localized(_ string: String) -> String {
        return NSLocalizedString(string, comment: "")
    }

#if os(iOS)
    public func calculateWidth(_ height: CGFloat, font: UIFont) -> CGFloat {
        let constraintRect = CGSize(width: .greatestFiniteMagnitude, height: height)
        let boundingBox = self.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: convertToOptionalNSAttributedStringKeyDictionary([convertFromNSAttributedStringKey(NSAttributedString.Key.font): font]), context: nil)

        return boundingBox.width
    }

#elseif os(OSX)
    public func calculateWidth(_ height: CGFloat, font: NSFont) -> CGFloat {
        let constraintRect = CGSize(width: .greatestFiniteMagnitude, height: height)
        var boundingBox: NSRect
        if #available(OSX 10.11, *) {
            boundingBox = self.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font], context: nil)
            return boundingBox.width
        } else {
            boundingBox = self.boundingRect(with: constraintRect, options: .usesLineFragmentOrigin, attributes: [NSAttributedString.Key.font: font])
        }
        return boundingBox.width
    }
#endif
}

extension CountableClosedRange {
    func clamp(_ value: Bound) -> Bound {
        return value < lowerBound ? lowerBound : (value > upperBound ? upperBound : value)
    }
}

public struct StringFunctions {
    private static let kValueMinimum: Int = 1
    private static let kValueMaximum: Int = 999

    private static func GenerateIncrementByNumberPreset(_ text: String) -> String {
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        var result: String = ""

        if !numberString.isEmpty {
            let kOffset: Int = 1
            numberString = OffsetNumberString(numberString, kOffset, kValueMinimum, kValueMaximum)

            result = numberString
        }

        return result
    }

    private static func IncrementCharacter(_ character: inout Character) {
        var string = ""
        for unicodeScalar in String(character).unicodeScalars {
            let newValue = unicodeScalar.value + 1
            if let newUnicodeScalar = UnicodeScalar(newValue) {
                string.append(Character(newUnicodeScalar))
            }
        }

        if let newChar = string.first {
            character = newChar
        }
    }

    private static func DecrementCharacter(_ character: inout Character) {
        var string = ""
        for unicodeScalar in String(character).unicodeScalars {
            let newValue = unicodeScalar.value - 1
            if let newUnicodeScalar = UnicodeScalar(newValue) {
                string.append(Character(newUnicodeScalar))
            }
        }

        if let newChar = string.first {
            character = newChar
        }
    }

    private static func GenerateIncrementByLetterPreset(_ text: String) -> String {
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        var result: String = ""

        if !numberString.isEmpty {
            // If the suffix string contains a letter, increment it.
            // ('Z' advances to 'a', however 'z' results in an increment
            // by number.)
            if !suffixString.isEmpty && !IsDigit(suffixString.first!) && suffixString.first! < "z" {
                var character: Character = suffixString.first!

                if character == "Z" {
                    character = "a"
                } else {
                    IncrementCharacter(&character)
                }

                result = numberString + String(character)
            } else {
                let kOffset: Int = 1
                result = OffsetNumberString(numberString, kOffset, kValueMinimum, kValueMaximum)
            }
        }

        return result
    }

    private static func GenerateDecrementByNumberPreset(_ text: String) -> String {
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        var result: String = ""

        if !numberString.isEmpty {
            let kOffset: Int = -1
            numberString = OffsetNumberString(numberString, kOffset, kValueMinimum, kValueMaximum)

            result = numberString
        }

        return result
    }

    private static func GenerateDecrementByLetterPreset(_ text: String) -> String {
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        var result: String = ""

        if !numberString.isEmpty {
            // If the suffix string contains a letter, decrement it.
            // ('a' advances to 'Z', however 'a' results in a decrement
            // by number.)
            if !suffixString.isEmpty && !IsDigit(suffixString.first!) && suffixString.first! > "A" {
                var character: Character = suffixString.first!

                if character == "a" {
                    character = "Z"
                } else {
                    DecrementCharacter(&character)
                }

                result = numberString + String(character)
            } else {
                let kOffset: Int = -1
                numberString = OffsetNumberString(numberString, kOffset, kValueMinimum, kValueMaximum)
                result = numberString
            }
        }

        return result
    }

    private static func ApplyPreset(_ text: inout String, _ presetString: String) {
        if presetString.isEmpty {
            return
        }

        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        var result: String = text

        if !numberString.isEmpty {
            // If the suffix string is empty, or it doesn't begin with a number,
            // just replace the number string only.
            if suffixString.isEmpty || IsDigit(suffixString.first!) {
                result = prefixString + presetString + suffixString
            } else {
                //result = prefixString + presetString + suffixString.substring(from: suffixString.index(after: suffixString.startIndex))
				let index = suffixString.index(after: suffixString.startIndex)
				result = prefixString + presetString + suffixString[index...]
            }
        }

        if result.count <= 5 {
            text = result
        }
    }

    public static func IncrementSceneString(_ text: String) -> String {
        var text = text
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        if !numberString.isEmpty {
            var presetString = ""

            if suffixString.isEmpty || IsDigit(suffixString.first!) || suffixString.first! == "z" {
                presetString = GenerateIncrementByNumberPreset(text)
            } else {
                presetString = GenerateIncrementByLetterPreset(text)
            }

            ApplyPreset(&text, presetString)
        }

        return text
    }

    public static func DecrementSceneString(_ text: String) -> String {
        var text = text
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)

        if !numberString.isEmpty {
            var presetString = ""

            if suffixString.isEmpty || IsDigit(suffixString.first!) || suffixString.first! == "A" {
                presetString = GenerateDecrementByNumberPreset(text)
            } else {
                presetString = GenerateDecrementByLetterPreset(text)
            }

            ApplyPreset(&text, presetString)
        }

        return text
    }

    private static func IsDigit(_ char: Character) -> Bool {
        return (char >= "0" && char <= "9")
    }

    private static func ParseValueString(_ text: String, _ prefixString: inout String, _ numberString: inout String, _ suffixString: inout String) {
        prefixString.removeAll()
        numberString.removeAll()
        suffixString.removeAll()

        var containsDigit: Bool = false

        // Advance to the end of the string, and determine whether
        // the string contains a digit.
        for char in text {
            if IsDigit(char) {
                containsDigit = true
                break
            }
        }

        // If the string is empty or doesn't contain a digit, return.
        if text.isEmpty || !containsDigit {
            return
        }

        // Iterate backwards through the string.
        // While a digit has not yet been found, add the characters
        // to the suffix string.
        let charArray: [Character] = text.reversed()
        var characterIndex = 0
        while !IsDigit(charArray[characterIndex]) {
            suffixString += String(charArray[characterIndex])
            characterIndex += 1
        }

        // While digits are found, add them to the number string.
        while characterIndex < charArray.count {
            if IsDigit(charArray[characterIndex]) {
                numberString += String(charArray[characterIndex])
                characterIndex += 1
            } else {
                break
            }
        }

        // Add the remaining characters to the prefix string.
        while characterIndex < charArray.count {
            prefixString += String(charArray[characterIndex])
            characterIndex += 1
        }

        // Reverse all the strings, since the characters were added to
        // them in reverse.
        prefixString = String(prefixString.reversed())
        numberString = String(numberString.reversed())
        suffixString = String(suffixString.reversed())
    }

    private static func OffsetNumberString(_ numberString: String, _ offset: Int, _ valueMinimum: Int, _ valueMaximum: Int) -> String {
        // Convert the number string to an integer.
        var number: Int? = Int(numberString)

        if number == nil {
            return numberString
        }

        // Add the offset to it.
        number! += offset
        number = (valueMinimum ... valueMaximum).clamp(number!)

        // Convert the number back to a string.
        let result = "\(number!)"

        return result
    }

    public static func GetNumberString(_ text: String) -> String {
        var prefixString = ""
        var suffixString = ""
        var numberString = ""

        ParseValueString(text, &prefixString, &numberString, &suffixString)
        return numberString
    }
	
	public static func UCS2ToUTF8(_ ucs2Buffer: Data) -> String {
		var str16Array = Array<UInt16>(repeating: 0, count: ucs2Buffer.count / MemoryLayout<UInt16>.stride)
		_ = str16Array.withUnsafeMutableBytes { ucs2Buffer.copyBytes(to: $0) }

		var str8Array = [UInt8]()
		for str16 in str16Array {
			str8Array.append(UInt8(str16))
		}
		
		let stringReturn = String(data: Data(str8Array[0..<str8Array.count - 1]), encoding: String.Encoding.utf8) ?? ""
		return stringReturn
	}
}

// Helper function inserted by Swift 4.2 migrator.
fileprivate func convertToOptionalNSAttributedStringKeyDictionary(_ input: [String: Any]?) -> [NSAttributedString.Key: Any]? {
	guard let input = input else { return nil }
	return Dictionary(uniqueKeysWithValues: input.map { key, value in (NSAttributedString.Key(rawValue: key), value)})
}

// Helper function inserted by Swift 4.2 migrator.
fileprivate func convertFromNSAttributedStringKey(_ input: NSAttributedString.Key) -> String {
	return input.rawValue
}
