/* -LICENSE-START-
 ** Copyright (c) 2020 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import CoreBluetooth
import Utility
import PTP

public class USBPTPController: PTPPacketDecoderDelegate, PTPPacketEncoderDelegate {
    private weak var m_usbPtpDevice: USBBulkDevice?
    weak var m_packetReceivedDelegate: PTPPacketDecoderDelegate?
    var m_isSessionOpened = false
	var m_sessionId: UInt8 = 1
	var m_transactionId: TransactionID = 1
	var m_commandContainer: Container = Container()
	var m_eventBuffer = [UInt8](repeating: 0, count: PTPTypes.kMaxPacketSize)
	var m_deviceInfo: PTPDeviceInfo?
	var m_deviceDescs = [PTPDevicePropDesc]()
	var m_recordStartedTransactionId: TransactionID = PTPTypes.kInvalidCaptureTransactionId
	
	// Responses are asynchronous
	internal struct PTPTransaction {
		var transactionId: TransactionID
		var operationCode: OperationCode
		var responseCode: ResponseCode
		var dataContainer: Container?
	}
	var m_transactionQueue = Queue<PTPTransaction>()
	let m_semaphore = DispatchSemaphore(value: 0)
	let m_serialQueue = DispatchQueue(label: "QueueSyncAccess")
	
	// Event polling
	let m_eventReadQueue = DispatchQueue(label: "EventReadQueue")
	var m_eventHandler: (() -> Void)?
	
	// PTP packet handlers
	let m_ptpEncoder = PTPPacketEncoder()

    public func getDevice() -> USBBulkDevice? { return m_usbPtpDevice }
    public func isSessionOpened() -> Bool { return m_isSessionOpened }

    public init(device: USBBulkDevice) {
        self.m_usbPtpDevice = device
		
		m_ptpEncoder.setDelegate(self)
		startReadEvent()
    }
	
	func startReadEvent() {
		m_eventReadQueue.async {
			// Note: Blocks while waiting for events to come through the interrupt pipe
			let bytesRead = self.m_usbPtpDevice!.readInterruptPipe(&self.m_eventBuffer)
			if bytesRead >= PTPTypes.kContainerHeaderSize {
				// Intercept events so that the controller can start a transaction to
				// 'get' the actual value for the event that was raised before sending
				// the value to the registered delegate.
				PTPPacketDecoder.DecodePacket(&self.m_eventBuffer, respondTo: self)
				
				// Start next read event as soon as we finish handling the last read event.
				self.startReadEvent()
			}
			else {
				Logger.LogWarning("Invalid PTP packet read")
			}
		}
	}
	
	public func setPacketDecodedDelegate(_ delegate: PTPPacketDecoderDelegate) {
		m_packetReceivedDelegate = delegate
	}
	
	internal func readFromUSBDevice() -> Bool {
		// Kick off a read on the PTP device
		var buffer = [UInt8](repeating: 0, count: PTPTypes.kMaxPacketSize)
		let bytesRead = m_usbPtpDevice!.readPipe(&buffer)
		if bytesRead >= PTPTypes.kContainerHeaderSize {
			// Intercept responses instead of responding to a registered delegate
			// since the response (OK or failed) is not useful outside of the protocol.
			PTPPacketDecoder.DecodePacket(&buffer, respondTo: self)
			return true
		}
		else {
			Logger.LogError("Invalid PTP packet read")
			// Optionally set pipe stall?
			return false
		}
	}
	
	// PTPPacketEncoderDelegate: Sending packet functions
	public func onPTPPacketEncoded(_ commandContainer: Container, _ dataContainer: Container?) -> Bool {
		if m_usbPtpDevice == nil {
			Logger.LogError("Cannot send command because we do not have a valid USB PTP device.")
			return false
		}
		
		// First send the command container
		let commandContainer = commandContainer
		if (m_usbPtpDevice!.writePipe(commandContainer.serializeContainerDataToByteArray()) == false) {
			Logger.LogError("Failed to write command to USB device. Transaction aborted")
			return false
		}

		// Then send the data container if non-nil
		let dataContainer = dataContainer
		if (dataContainer != nil) {
			if (m_usbPtpDevice!.writePipe((dataContainer?.serializeContainerDataToByteArray())!) == false) {
				Logger.LogError("Failed to write data to USB device. Transaction aborted")
				return false
			}
		}
		
		let operationCode = OperationCode(rawValue: commandContainer.m_containerData.code) ?? OperationCode.Undefined
		Logger.LogWithInfo("\(#function) Encoded Operation: \(operationCode) for Transaction: \(m_transactionId)")
		
		m_serialQueue.sync {
			m_transactionQueue.enqueue(element: PTPTransaction(transactionId: m_transactionId, operationCode: operationCode, responseCode: ResponseCode.Undefined, dataContainer: nil))
		}

		// Transaction ID is incremented for every packet sent regardless of success/failure
		m_transactionId += 1
		
		return readFromUSBDevice()
	}
	
	// PTPPacketDecoderDelegate
	public func onResponseReceived(_ transactionId: TransactionID, _ responseCode: ResponseCode) {
		// We only need to interact with the first transaction in the queue since we must receive a response for every request sequentially.
		// The PTP standard dictates that there can only be one transaction at a time that can take place within a session.
		// Raise an error if we detect transaction out of order, and dequeue it immediately.
		m_serialQueue.sync {
			var maxDequeueAllowed = m_transactionQueue.count()
			while (maxDequeueAllowed > 0) {
				// Get the first queued transaction
				let queuedTransactionId = m_transactionQueue.get(index: 0)?.transactionId
				if queuedTransactionId! == transactionId {
					m_transactionQueue.withReferenceToIndex(index: 0) { (item: inout PTPTransaction) in
						if (item.transactionId == transactionId) {
							item.responseCode = responseCode
						}
					}
					break
				}
				else if queuedTransactionId! > transactionId {
					Logger.LogError("Ignoring response for a past transaction. ID: \(String(describing: queuedTransactionId))")
					break
				}
				else if queuedTransactionId! < transactionId{
					Logger.LogError("Discarding PTP transaction ID: \(String(describing: queuedTransactionId)) due to receiving response for a later transaction ID: \(String(describing: transactionId))")
					_ = m_transactionQueue.dequeue()	// discard
				}
				
				maxDequeueAllowed -= 1
			}
		}

		Logger.Log("\(#function) signaling now")
		m_semaphore.signal()
	}
	
	public func onDataReceived(_ dataContainer: Container) {
		// Similar to onResponseReceived, data phase cannot occur without a command first requesting for data.
		// But don't discard any transactions here since data phase is optional and may not happen for every transaction.
		// Allow onResponseReceived to perform the check and discard.
		m_serialQueue.sync {
			for i in 0..<m_transactionQueue.count() {
				let queuedTransactionId = m_transactionQueue.get(index: 0)?.transactionId
				if queuedTransactionId! == dataContainer.m_containerData.transactionId {
					m_transactionQueue.withReferenceToIndex(index: i) { (item: inout PTPTransaction) in
						item.dataContainer = dataContainer
					}
					break
				}
			}
		}
		
		// Kick off a read on the PTP device for the response since we just received the optional data phase container
		_ = readFromUSBDevice()
	}
	
	public func onDevicePropertyChanged(_ devicePropCode: DevicePropCode) {
		Logger.Log("\(#function)")
		switch devicePropCode {
		case .FNumber:					readApertureFNumber()
		case .ExposureIndex:			readExposureIndex()
		case .BMD_ShutterAngle:			readShutterAngle()
		case .BMD_WhiteBalanceKelvin:	readWhiteBalance()
		case .BMD_WhiteBalanceTint:		readTint()
		case .BMD_FrameRate:			readFrameRate()
		case .BMD_OffSpeedFrameRate:	readOffSpeedFrameRate()
		case .BMD_OffSpeedEnabled:		readOffSpeedEnabled()
		case .BMD_RecordingState:		readRecordingState()
		case .BMD_NDFilter:				readNDFilter()
		default:						break
		}
	}
	
	public func onDevicePropertyDescriptionChanged(_ devicePropCode: DevicePropCode) {
		Logger.Log("\(#function)")
        _ = getDevicePropDesc(devicePropCode);
	}
	
	public func onDevicePropDescReceived(_ devicePropDesc: PTPDevicePropDesc) {
		m_deviceDescs = m_deviceDescs.filter { $0.m_devicePropCode != devicePropDesc.m_devicePropCode }
		m_deviceDescs.append(devicePropDesc)
	}
	
	internal func waitForResponse() -> PTPTransaction? {
		Logger.Log("\(#function)")
		if (m_semaphore.wait(wallTimeout: .now() + .milliseconds(500)) == .timedOut) {
			Logger.Log("\(#function) return nil")
			return nil
		}
		
		var lastTransaction: PTPTransaction?
		m_serialQueue.sync {
			lastTransaction = m_transactionQueue.dequeue()
		}
		
		return lastTransaction
	}
	
	public func openSession(forceClosePreviousSessionIfPresent: Bool) -> Bool {
		let openSessionSuccessful = openSession()
		if !openSessionSuccessful && forceClosePreviousSessionIfPresent {
			_ = closeSession()
			return openSession()
		}
		
		return openSessionSuccessful
	}
	
	public func openSession() -> Bool {
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeOpenSessionCommand(m_transactionId, m_sessionId) {
			if let ptpTransaction = waitForResponse() {
				if ptpTransaction.responseCode == ResponseCode.OK {
					m_sessionId += 1
					m_isSessionOpened = true
					
					// For update of all device info and supported operations, events and device prop codes
					_ = getDeviceInfo()
					return true
				}
			}
		}

		Logger.LogError("Failed to open session")
		return false
	}
	
	public func closeSession() -> Bool {
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeCloseSessionCommand(m_transactionId) {
			if let ptpTransaction = waitForResponse() {
				if ptpTransaction.responseCode == ResponseCode.OK {
					m_isSessionOpened = false
					return true
				}
			}
		}
		
		Logger.LogError("Failed to close session")
		return false
	}
	
	public func getDeviceInfo() -> Bool {
		Logger.Log("\(#function)")
		guard (m_ptpEncoder.encodeGetDeviceInfoCommand(m_transactionId) == true) else { return false }

		let ptpTransaction = waitForResponse()
		guard (ptpTransaction?.responseCode == ResponseCode.OK) else { return false }
		guard (ptpTransaction?.dataContainer) != nil else { return false }
		
		// Deserialise device info
		if let payloadDecodedDelegate = m_packetReceivedDelegate, let dataContainer = ptpTransaction?.dataContainer {
			m_deviceInfo = PTPPacketDecoder.DecodePayloadAsDeviceInfo(dataContainer, respondTo: payloadDecodedDelegate)
			
			// Ensure we get the latest value of each supported device prop code and fire the value to the delegate
			if let supportedDevicePropCode = m_deviceInfo?.m_supportedDevicePropCode {
				for devicePropCode in supportedDevicePropCode {
					_ = getDevicePropValue(devicePropCode)
					_ = getDevicePropDesc(devicePropCode)
				}
			}
			
			return true
		}
		
		return false
	}
	
	public func getDevicePropDesc(_ devicePropCode: DevicePropCode) -> Bool {
		Logger.Log("\(#function), devicePropCode = \(devicePropCode)")
		guard (m_ptpEncoder.encodeGetDevicePropDescCommand(m_transactionId, devicePropCode) == true) else { return false }

		let ptpTransaction = waitForResponse()
		guard (ptpTransaction?.responseCode == ResponseCode.OK) else { return false }
		guard (ptpTransaction?.dataContainer) != nil else { return false }
		
		if let dataContainer = ptpTransaction?.dataContainer {
			// Let self keep a copy for now.
			_ = PTPPacketDecoder.DecodePayloadAsDevicePropDesc(dataContainer, respondTo: self)
			
			// Deserialise device prop desc
			if let payloadDecodedDelegate = m_packetReceivedDelegate, let dataContainer = ptpTransaction?.dataContainer {
				_ = PTPPacketDecoder.DecodePayloadAsDevicePropDesc(dataContainer, respondTo: payloadDecodedDelegate)
				return true
			}
		}
		
		return false
	}
	
	public func stillCapture() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeStillCaptureCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func startRecord() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeStartRecordCommand(m_transactionId) {
			if let ptpTransaction = waitForResponse() {
				if ptpTransaction.responseCode == ResponseCode.OK {
					m_recordStartedTransactionId = ptpTransaction.dataContainer?.m_containerData.transactionId ?? PTPTypes.kInvalidCaptureTransactionId
				}
			}
		}

		return false
	}
	
	public func stopRecord() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeStopRecordCommand(m_transactionId, m_recordStartedTransactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func changeFocus(_ nearer: Bool, _ steps: UInt32) -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function) nearer = \(nearer), steps = \(steps)")
		if m_ptpEncoder.encodeChangeFocusCommand(m_transactionId, nearer, steps) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func autoFocus(xPosRatio: Float = 0, yPosRatio: Float = 0) -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeAutoFocusCommand(m_transactionId, xPosRatio, yPosRatio) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func cancelAutoFocus(xPosRatio: Float = 0, yPosRatio: Float = 0) -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeCancelAutoFocusCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func enableAutoExposure() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeEnableAutoExposureCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func disableAutoExposure() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeDisableAutoExposureCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func enableAutoWhiteBalance() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeEnableAutoWhiteBalanceCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func disableAutoWhiteBalance() -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function)")
		if m_ptpEncoder.encodeDisableAutoWhiteBalanceCommand(m_transactionId) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}

		return false
	}
	
	public func getDevicePropValue(_ devicePropCode: DevicePropCode) -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function) Device Prop Code: \(devicePropCode)")
		_ = m_ptpEncoder.encodeGetDevicePropValueCommand(m_transactionId, devicePropCode)
		
		if let ptpTransaction = waitForResponse(), let dataContainer = ptpTransaction.dataContainer, let payloadDecodedDelegate = m_packetReceivedDelegate {
			if ptpTransaction.responseCode == ResponseCode.OK {
				_ = PTPPacketDecoder.DecodePayloadAsDevicePropValue(dataContainer, devicePropCode, respondTo: payloadDecodedDelegate, m_deviceDescs)
				return true
			}
		}
		
		return false
	}
	
	@discardableResult public func readBatteryLevel() -> Bool { return getDevicePropValue(DevicePropCode.BatteryLevel) }
	@discardableResult public func readImageSize() -> Bool { return getDevicePropValue(DevicePropCode.ImageSize) }
	@discardableResult public func readApertureFNumber() -> Bool { return getDevicePropValue(DevicePropCode.FNumber) }
	@discardableResult public func readFocalLength() -> Bool { return getDevicePropValue(DevicePropCode.FocalLength) }
	@discardableResult public func readFocusDistance() -> Bool { return getDevicePropValue(DevicePropCode.FocusDistance) }
	@discardableResult public func readExposureIndex() -> Bool { return getDevicePropValue(DevicePropCode.ExposureIndex) }
	@discardableResult public func readShutterSpeed() -> Bool { return getDevicePropValue(DevicePropCode.BMD_ShutterSpeed) }
	@discardableResult public func readShutterAngle() -> Bool { return getDevicePropValue(DevicePropCode.BMD_ShutterAngle) }
	@discardableResult public func readFocusPosition() -> Bool { return getDevicePropValue(DevicePropCode.BMD_FocusPosition) }
	@discardableResult public func readWhiteBalance() -> Bool { return getDevicePropValue(DevicePropCode.BMD_WhiteBalanceKelvin) }
	@discardableResult public func readTint() -> Bool { return getDevicePropValue(DevicePropCode.BMD_WhiteBalanceTint) }
	@discardableResult public func readFrameRate() -> Bool { return getDevicePropValue(DevicePropCode.BMD_FrameRate) }
	@discardableResult public func readOffSpeedFrameRate() -> Bool { return getDevicePropValue(DevicePropCode.BMD_OffSpeedFrameRate) }
	@discardableResult public func readOffSpeedEnabled() -> Bool { return getDevicePropValue(DevicePropCode.BMD_OffSpeedEnabled) }
	@discardableResult public func readZoomPosition() -> Bool { return getDevicePropValue(DevicePropCode.BMD_ZoomPosition) }
	@discardableResult public func readRecordingState() -> Bool { return getDevicePropValue(DevicePropCode.BMD_RecordingState) }
	@discardableResult public func readNDFilter() -> Bool { return getDevicePropValue(DevicePropCode.BMD_NDFilter) }
	
	public func writeDevicePropValue<T>(_ devicePropCode: DevicePropCode, _ arg: T) -> Bool {
		if (!m_isSessionOpened) {
			return false
		}
		
		Logger.Log("\(#function) Device Prop Code: \(devicePropCode), Value: \(arg)")
		if m_ptpEncoder.encodeSetDevicePropValueCommand(m_transactionId, devicePropCode, arg) {
			return waitForResponse()?.responseCode == ResponseCode.OK
		}
		
		return false
	}
    
    private func normalisedApertureToFNumber(_ normalisedAperture: Float) -> UInt16 {
        let deviceDesc = m_deviceDescs.first { $0.m_devicePropCode == DevicePropCode.FNumber }
        if deviceDesc != nil {
            let fstops = deviceDesc?.getEnumValues() as! [UInt16]
            let maxFstop = deviceDesc?.getMaximumValue() as! UInt16
            let minFstop = deviceDesc?.getMinimumValue() as! UInt16
            let fstop = Int( (normalisedAperture * Float(maxFstop - minFstop)) + Float(minFstop))
            return fstops.reduce(0, { prev, curr in abs(Int(curr) - fstop) < abs(Int(prev) - fstop) ? curr : prev })
        }
        return 0;
    }
	
	public func writeApertureNormalised(_ normalisedAperture: Float) -> Bool {
        return writeDevicePropValue(DevicePropCode.FNumber, normalisedApertureToFNumber(normalisedAperture))
	}
    
    public func incrementAperture(_ currentApertureNormalised: Float) -> Bool {
        let deviceDesc = m_deviceDescs.first { $0.m_devicePropCode == DevicePropCode.FNumber }
        if deviceDesc != nil {
            let fstops = deviceDesc?.getEnumValues() as! [UInt16]
            if let currentIndex = fstops.firstIndex(of: normalisedApertureToFNumber(currentApertureNormalised))
            {
                let fnumberX100 = fstops[min(currentIndex + 1, fstops.count - 1)]
                return writeDevicePropValue(DevicePropCode.FNumber, fnumberX100)
            }
        }
        return false;
    }
    
    public func decrementAperture(_ currentApertureNormalised: Float) -> Bool {
        let deviceDesc = m_deviceDescs.first { $0.m_devicePropCode == DevicePropCode.FNumber }
        if deviceDesc != nil {
            let fstops = deviceDesc?.getEnumValues() as! [UInt16]
            if let currentIndex = fstops.firstIndex(of: normalisedApertureToFNumber(currentApertureNormalised))
            {
                let fnumberX100 = fstops[max(currentIndex - 1, 0)]
                return writeDevicePropValue(DevicePropCode.FNumber, fnumberX100)
            }
        }
        return false;
    }

	public func writeApertureFNumber(_ fnumberX100: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.FNumber, fnumberX100) }
	public func writeFocalLength(_ focalLength: UInt32) -> Bool { return writeDevicePropValue(DevicePropCode.FocalLength, focalLength) }
	public func writeFocusDistance(_ focusDistance: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.FocusDistance, focusDistance) }
	public func writeExposureIndex(_ exposureIndex: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.ExposureIndex, exposureIndex) }
	public func writeShutterSpeed(_ shutterSpeed: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_ShutterSpeed, shutterSpeed) }
	public func writeShutterAngle(_ shutterAngle: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_ShutterAngle, shutterAngle) }
	public func writeFocusPosition(_ focusPosition: Int32) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_FocusPosition, focusPosition) }
	public func writeWhiteBalance(_ whiteBalance: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_WhiteBalanceKelvin, whiteBalance) }
	public func writeTint(_ tint: Int8) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_WhiteBalanceTint, tint) }
	public func writeFrameRate(_ frameRate: UInt32) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_FrameRate, frameRate) }
	public func writeOffSpeedFrameRate(_ offSpeedFrameRate: UInt32) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_OffSpeedFrameRate, offSpeedFrameRate) }
	public func writeZoomPosition(_ zoomPosition: UInt16) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_ZoomPosition, zoomPosition) }
	public func writeOffSpeedEnabled(_ offSpeedEnabled: Bool) -> Bool {
		let kEnableOffSpeed: UInt32 = 1
		let kDisableOffSpeed: UInt32 = 0
		return writeDevicePropValue(DevicePropCode.BMD_OffSpeedEnabled, offSpeedEnabled ? kEnableOffSpeed : kDisableOffSpeed)
	}
	public func writeNDFilter(_ ndFilter: PTPTypes.ptp_fixed_t) -> Bool { return writeDevicePropValue(DevicePropCode.BMD_NDFilter, ndFilter) }
	
}
