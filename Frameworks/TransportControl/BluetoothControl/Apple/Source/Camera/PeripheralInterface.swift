/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
import CoreBluetooth
import Utility
#if os(iOS)
import UIKit
#endif

// Incoming/Outgoing Packets
public protocol PacketReceivedDelegate: AnyObject {
    func onSuccessfulPairing(_ cameraName: String)
    func onTimecodePacketReceived(_ data: Data?)
    func onCameraStatusPacketReceived(_ data: Data?)
    func onCCUPacketReceived(_ data: Data?)
    func onCameraModelPacketReceived(_ data: Data?)
    func onWriteValueErrorReported(_ error: Error)
    func onReadValueErrorReported(_ error: Error)
    func onCameraNameChanged(_ cameraName: String)
    func onProtocolVersionReceived(_ peripheral: CBPeripheral, _ data: Data?)
}

public extension PacketReceivedDelegate {
	func onSuccessfulPairing(_ cameraName: String) {}
	func onTimecodePacketReceived(_ data: Data?) {}
	func onCameraStatusPacketReceived(_ data: Data?) {}
	func onCCUPacketReceived(_ data: Data?) {}
	func onCameraModelPacketReceived(_ data: Data?) {}
	func onWriteValueErrorReported(_ error: Error) {}
	func onReadValueErrorReported(_ error: Error) {}
	func onCameraNameChanged(_ cameraName: String) {}
	func onProtocolVersionReceived(_ peripheral: CBPeripheral, _ data: Data?) {}
}

public class PeripheralInterface: NSObject, CBPeripheralDelegate {
    private weak var m_peripheral: CBPeripheral?
    weak var m_packetReceivedDelegate: PacketReceivedDelegate?
    var m_isPaired = false
    var m_discoveredPowerCharacteristic: Bool = false
    var m_discoveredNameCharacteristic: Bool = false
	var m_setPowerCharacteristic: Bool = true

    public func getPeripheral() -> CBPeripheral? { return m_peripheral }
    public func isPaired() -> Bool { return m_isPaired }

    public init(peripheral: CBPeripheral) {
        super.init()

        m_peripheral = peripheral
        m_peripheral!.delegate = self
        m_peripheral!.discoverServices(BMDCameraServices.kAdvertisedServiceUUIDs)
    }
	
	public func setDelegate(_ delegate: PacketReceivedDelegate) {
		m_packetReceivedDelegate = delegate
	}

    // Sending packet functions
    public func sendPacket(_ data: Data, _ serviceUUID: CBUUID, _ characterisitcUUID: CBUUID) {
        if m_peripheral == nil {
            Logger.LogError("Cannot send command because we do not have a valid peripheral.")
            return
        }

        let characteristic: CBCharacteristic? = getCharacteristicForService(serviceUUID, characterisitcUUID)
        if characteristic != nil {
            m_peripheral!.writeValue(data, for: characteristic!, type: CBCharacteristicWriteType.withResponse)
        }
    }

    public func sendCCUPacket(_ data: Data) {
        sendPacket(data, BMDCameraServices.kMainService, BMDCameraCharacteristics.kOutgoingCCU)
    }

    public func sendPowerPacket(_ data: Data) {
        sendPacket(data, BMDCameraServices.kMainService, BMDCameraCharacteristics.kCameraStatus)
    }

    // Receiving packet functions
    func onCharacteristicUpdated(_ peripheral: CBPeripheral, _ characteristic: CBCharacteristic) {
        if characteristic.uuid == BMDCameraCharacteristics.kTimecode {
            m_packetReceivedDelegate?.onTimecodePacketReceived(characteristic.value)
        } else if characteristic.uuid == BMDCameraCharacteristics.kCameraStatus {
            m_packetReceivedDelegate?.onCameraStatusPacketReceived(characteristic.value)
        } else if characteristic.uuid == BMDCameraCharacteristics.kIncomingCCU {
            m_packetReceivedDelegate?.onCCUPacketReceived(characteristic.value)
        } else if characteristic.uuid == BMDCameraCharacteristics.kCameraModel {
            m_packetReceivedDelegate?.onCameraModelPacketReceived(characteristic.value)
        } else if characteristic.uuid == BMDCameraCharacteristics.kProtocolVersion {
            m_packetReceivedDelegate?.onProtocolVersionReceived(peripheral, characteristic.value)
        }
    }

    func getCharacteristicForService(_ desiredService: CBUUID, _ desiredCharacteristic: CBUUID) -> (CBCharacteristic?) {
        var validService: CBService?
        if let services = m_peripheral?.services {
            let filteredServices: [CBService] = services.filter { $0.uuid == desiredService }
            validService = filteredServices.count > 0 ? filteredServices[0] : nil
        }

        if validService != nil {
            let characteristics = validService!.characteristics
            if characteristics != nil {
                let filteredCharacteristics: [CBCharacteristic] = characteristics!.filter { $0.uuid == desiredCharacteristic }
                return filteredCharacteristics.count > 0 ? filteredCharacteristics[0] : nil
            }
        }

        return nil
    }

    func canInitiateBond() -> Bool {
        let deviceNameCharacteristicDiscovered: Bool = getCharacteristicForService(BMDCameraServices.kMainService, BMDCameraCharacteristics.kDeviceName) != nil
        let cameraStatusCharacteristicDiscovered: Bool = getCharacteristicForService(BMDCameraServices.kMainService, BMDCameraCharacteristics.kCameraStatus) != nil
        return deviceNameCharacteristicDiscovered && cameraStatusCharacteristicDiscovered
    }

    func initiateBond() {
        // Send our device name
        let deviceNameCharacteristic: CBCharacteristic? = getCharacteristicForService(BMDCameraServices.kMainService, BMDCameraCharacteristics.kDeviceName)
        if deviceNameCharacteristic != nil {
	#if os(iOS)
		let nameData = UIDevice.current.name.data(using: .utf8) ?? "iPad".data(using: .utf8)!
	#elseif os(OSX)
		let nameData = NSUserName().data(using: .utf8) ?? "Mac".data(using: .utf8)!
	#endif
            m_peripheral?.writeValue(nameData, for: deviceNameCharacteristic!, type: CBCharacteristicWriteType.withResponse)
        }

        // Query power characteristic to instigate pairing
        let powerCharacteristic: CBCharacteristic? = getCharacteristicForService(BMDCameraServices.kMainService, BMDCameraCharacteristics.kCameraStatus)
        if powerCharacteristic != nil && m_setPowerCharacteristic {
            m_peripheral?.writeValue(CameraStatus.kPowerOn, for: powerCharacteristic!, type: CBCharacteristicWriteType.withResponse)
        }
    }
	
	public func setPowerCharacteristic(_ setPowerCharacteristic: Bool) {
		m_setPowerCharacteristic = setPowerCharacteristic
	}

    // CBPeripheralDelegate callbacks

    // didDiscoverServices
    public func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        if error != nil {
            Logger.LogError("\(error!)")
            return
        }

        if let services = peripheral.services {
            for service in services {
                if service.uuid == BMDCameraServices.kMainService {
                    peripheral.discoverCharacteristics(BMDCameraCharacteristics.kMainCharacteristicUUIDs, for: service)
                } else if service.uuid == BMDCameraServices.kCameraInformationService {
                    peripheral.discoverCharacteristics(BMDCameraCharacteristics.kCameraInfoCharacteristicUUIDs, for: service)
                }
            }
        }
    }

    // didDiscoverCharacteristicsFor
    public func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        if error != nil {
            Logger.LogError("CBPeripheralDelegate::didDiscoverCharacteristicsFor \(error!)")
            return
        }

        if let characteristics = service.characteristics {
            for characteristic in characteristics {

                if characteristic.uuid == BMDCameraCharacteristics.kCameraStatus {
                    m_discoveredPowerCharacteristic = true
                }

                if characteristic.uuid == BMDCameraCharacteristics.kDeviceName {
                    m_discoveredNameCharacteristic = true
                }

                if characteristic.uuid == BMDCameraCharacteristics.kProtocolVersion {
                    peripheral.readValue(for: characteristic)
                }

                peripheral.setNotifyValue(true, for: characteristic)
            }
        }

        if canInitiateBond() {
            initiateBond()
        }
    }

    // didUpdateValueFor
    public func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        if let error = error {
            Logger.LogError("CBPeripheralDelegate::didUpdateValueFor \(error)")
            m_packetReceivedDelegate?.onReadValueErrorReported(error)
            return
        }

        let characteristicIsEncrypted = BMDCameraCharacteristics.IsCharacteristicEncrypted(characteristic.uuid)
        if !m_isPaired && characteristicIsEncrypted {
            m_packetReceivedDelegate?.onSuccessfulPairing(peripheral.name ?? "Blackmagic Design Camera")
            m_isPaired = true
        }

        onCharacteristicUpdated(peripheral, characteristic)
    }

    // didWriteValueFor
    public func peripheral(_: CBPeripheral, didWriteValueFor _: CBCharacteristic, error: Error?) {
        if let error = error {
            Logger.LogError("CBPeripheralDelegate::didWriteValueFor \(error)")
            m_packetReceivedDelegate?.onWriteValueErrorReported(error)
            return
        }
    }

    public func peripheralDidUpdateName(_ peripheral: CBPeripheral) {
        if let cameraName = peripheral.name {
            m_packetReceivedDelegate?.onCameraNameChanged(cameraName)
        }
    }
}
