/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

import Foundation
#if os(iOS)
import UIKit
#endif
import CoreBluetooth
import Utility

// This extension method is a workaround of a bug introduced in macOS 10.13, which
// makes CBPeripheral.identifier inaccessible on earlier platforms.
// Bug desribed here: https://forums.developer.apple.com/message/250969
extension CBPeripheral {
	public func getPeripheralIdentifier() -> UUID {
		if #available(OSX 10.13, *) {
			return self.identifier
		} else {
			// Fallback on earlier versions
			if let id = self.value(forKey: "identifier") as? UUID {
				return id
			}
		}
		return UUID()
	}
}

public protocol BluetoothConnectionManagerDelegate: AnyObject {
    func updateDiscoveredPeripheralList(_ discoveredPeripheralList: [DiscoveredPeripheral])
    func connectedToPeripheral(_ peripheral: CBPeripheral)
    func onConnectionLost()
	func onConnectionFailed(with error: Error?)
    func onDisconnected(with error: Error?)
    func onReconnection()
    func isConnected() -> Bool
}

public class BluetoothConnectionManager: NSObject, CBCentralManagerDelegate {
    // Properties
    var m_centralManager: CBCentralManager!
    var m_discoveredPeripheralList = [DiscoveredPeripheral]()
    var m_targetPeripheral: CBPeripheral?
    var m_connectionManagerDelegate: BluetoothConnectionManagerDelegate?
    var m_errorCausingDisconnection: Error?
	var m_centralManagerReady: Bool = false

    var m_discoveryTimeoutTimer: Timer?
    var m_checkExistingConnectionsTimer: Timer?
    private var m_disconnectedPeripheralIdentifier: UUID?
    private var m_attemptingReconnection: Bool = false
    
    public typealias ErrorType = (domain:String,code:Int)
    public static let kPairingFailClearDeviceErrors: [ErrorType] = [(CBErrorDomain, 7), (CBErrorDomain, 8), (CBATTErrorDomain, 14), (CBErrorDomain, 14)]
    public static let kPairingFailTryAgainErrors: [ErrorType] = [(CBATTErrorDomain, 15), (CBATTErrorDomain, 5)]

    public override init() {
        super.init()
        m_centralManager = CBCentralManager(delegate: self as CBCentralManagerDelegate, queue: nil)
		
    #if os(iOS)
        let app = UIApplication.shared
        NotificationCenter.default.addObserver(self, selector: #selector(BluetoothConnectionManager.applicationWillResignActive), name: UIApplication.willResignActiveNotification, object: app)
    #endif
    }
	
	public func setDelegate(_ delegate: BluetoothConnectionManagerDelegate) {
		m_connectionManagerDelegate = delegate
	}

    // Discovery and Connection
    public func startScanning(_ central: CBCentralManager) {
        central.scanForPeripherals(withServices: BMDCameraServices.kAdvertisedServiceUUIDs, options: [CBCentralManagerScanOptionAllowDuplicatesKey: true])
        startCheckingExistingConnections()
    }

    public func refreshScan() {
        m_discoveredPeripheralList.removeAll()
		
		if m_centralManagerReady {
			m_centralManager.stopScan()
			startScanning(m_centralManager)
		}
    }

    public func attemptConnection(to identifier: UUID) {
        let filteredPeripherals = m_discoveredPeripheralList.filter { $0.peripheral.getPeripheralIdentifier() == identifier }
        if filteredPeripherals.count > 0 {
            let peripheralToConnect = filteredPeripherals[0].peripheral
            m_centralManager.connect(peripheralToConnect, options: nil)
            m_targetPeripheral = peripheralToConnect
        }
    }
	
	@objc func applicationWillResignActive() {
		if m_attemptingReconnection {
			m_attemptingReconnection = false
			if let peripheral = m_targetPeripheral {
				m_centralManager.cancelPeripheralConnection(peripheral)
			}
		}
	}

    @objc func updateReconnection(_ timer: Timer) {
        if let targetIdentifier = m_disconnectedPeripheralIdentifier {
            let ids: [UUID] = [targetIdentifier]
            let peripherals: [CBPeripheral] = m_centralManager.retrievePeripherals(withIdentifiers: ids)
            for peripheral in peripherals {
				if peripheral.getPeripheralIdentifier() == targetIdentifier {
                    m_targetPeripheral = peripheral
                    m_centralManager.connect(peripheral, options: nil)
					timer.invalidate()
                    break
                }
            }
        } else {
            timer.invalidate()
            m_attemptingReconnection = false
        }
    }

    public func attemptReconnection() {
        let timer = Timer.scheduledTimer(timeInterval: 2.0, target: self, selector: #selector(updateReconnection), userInfo: nil, repeats: true)
        timer.tolerance = 0.2

        updateReconnection(timer)

        m_attemptingReconnection = true
    }

    public func disconnect(from peripheral: CBPeripheral, with error: Error? = nil) {
        m_centralManager.cancelPeripheralConnection(peripheral)
        m_disconnectedPeripheralIdentifier = nil
        m_errorCausingDisconnection = error
		m_targetPeripheral = nil
    }

    public func hasPeripheralBeenDiscovered(_ peripheral: CBPeripheral) -> Bool {
		let discoveredUUID = peripheral.getPeripheralIdentifier()
		let filteredPeripherals = m_discoveredPeripheralList.filter { $0.peripheral.getPeripheralIdentifier() == discoveredUUID }
        let alreadyDiscovered = filteredPeripherals.count > 0

        return alreadyDiscovered
    }
    
    @objc func checkExistingConnections() {
        let connectedPeripherals: [CBPeripheral] = m_centralManager.retrieveConnectedPeripherals(withServices: BMDCameraServices.kAdvertisedServiceUUIDs)
        for peripheral in connectedPeripherals {
            attemptToAddPeripheral(peripheral)
        }
    }
    
    public func startCheckingExistingConnections() {
        checkExistingConnections()
        m_checkExistingConnectionsTimer?.invalidate()
        m_checkExistingConnectionsTimer = Timer.scheduledTimer(timeInterval: 3.0, target: self, selector: #selector(checkExistingConnections), userInfo: nil, repeats: true)
        m_checkExistingConnectionsTimer?.tolerance = 0.3
    }

    @objc private func countdownDiscoveryTimeout() {
        let reversedRange = (0 ..< m_discoveredPeripheralList.count).reversed()
        for index in reversedRange {
            let discoveredPeripheral = m_discoveredPeripheralList[index]
            discoveredPeripheral.timeoutCounter -= 1
            if discoveredPeripheral.timeoutCounter < 0 {
                m_discoveredPeripheralList.remove(at: index)
            }
        }

        m_connectionManagerDelegate?.updateDiscoveredPeripheralList(m_discoveredPeripheralList)

        if m_discoveredPeripheralList.count == 0 {
            m_discoveryTimeoutTimer?.invalidate()
            m_discoveryTimeoutTimer = nil
        }
    }

    private func attemptToAddPeripheral(_ peripheral: CBPeripheral) {
        let alreadyDiscovered = hasPeripheralBeenDiscovered(peripheral)
        if !alreadyDiscovered {
            if let peripheralName = peripheral.name {
                // Add peripheral to our discovered list
                let discoveredPeripheral = DiscoveredPeripheral(peripheral: peripheral, name: peripheralName)
                m_discoveredPeripheralList.append(discoveredPeripheral)
                m_connectionManagerDelegate?.updateDiscoveredPeripheralList(m_discoveredPeripheralList)

                if m_discoveryTimeoutTimer == nil {
                    m_discoveryTimeoutTimer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(countdownDiscoveryTimeout), userInfo: nil, repeats: true)
                }
            }
        } else {
            m_discoveredPeripheralList.forEach {
				if $0.peripheral.getPeripheralIdentifier() == peripheral.getPeripheralIdentifier() {
                    $0.restartTimeoutCounter()
                }
            }
        }
    }
	
	//==================================================
	//	CBCentralManagerDelegate methods
	//==================================================
	
	public func centralManagerDidUpdateState(_ central: CBCentralManager) {
		
    #if os(iOS)
        m_centralManagerReady = (central.state == CBManagerState.poweredOn)
    #else
        // Comparing rawValues to work around an SDK change between macOS 10.12 and 10.13.
        // 'central.state' changed types, but the raw values stayed the same. This workaround
        // allows us to support a range of SDKs.
        m_centralManagerReady = (central.state.rawValue == CBCentralManagerState.poweredOn.rawValue)
    #endif
		
		if m_centralManagerReady {
			startScanning(central)
		}
	}
	
	public func centralManager(_: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData _: [String: Any], rssi _: NSNumber) {
		attemptToAddPeripheral(peripheral)
	}

    public func centralManager(_: CBCentralManager, didConnect peripheral: CBPeripheral) {
        let isConnected = m_connectionManagerDelegate?.isConnected() ?? false
        if !isConnected {
            m_connectionManagerDelegate?.connectedToPeripheral(peripheral)
            m_connectionManagerDelegate?.onReconnection()
            m_attemptingReconnection = false
            m_disconnectedPeripheralIdentifier = nil
            m_centralManager.stopScan()
            m_discoveredPeripheralList.removeAll()
            m_discoveryTimeoutTimer?.invalidate()
            m_discoveryTimeoutTimer = nil
            m_checkExistingConnectionsTimer?.invalidate()
            m_checkExistingConnectionsTimer = nil        
		}
    }

    public func centralManager(_: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
		m_errorCausingDisconnection = error ?? m_errorCausingDisconnection
		
		var runningInBackground = false
    #if os(iOS)
        let app = UIApplication.shared
        runningInBackground = (app.applicationState == UIApplication.State.background)
    #endif
		
        if !runningInBackground && error != nil {
            Logger.LogWithInfo("Peripheral disconnected: \(error!).")
            let nsError = error! as NSError
           	let intentionalDisconnection = nsError.domain == CBErrorDomain && nsError.code == 7
            if !intentionalDisconnection {
				m_disconnectedPeripheralIdentifier = peripheral.getPeripheralIdentifier()
                m_connectionManagerDelegate?.onConnectionLost()
                attemptReconnection()
                return
            }
        }

        m_connectionManagerDelegate?.onDisconnected(with: m_errorCausingDisconnection)
        refreshScan()
    }

    public func centralManager(_: CBCentralManager, didFailToConnect _: CBPeripheral, error: Error?) {
		m_connectionManagerDelegate?.onConnectionFailed(with: error)
        Logger.LogWithInfo("Failed to connect to peripheral: \(String(describing: error)).")
    }
}
